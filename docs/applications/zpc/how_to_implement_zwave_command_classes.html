<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Guideline for implementing Command Classes &mdash; Unify Host SDK</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom_styles.css" type="text/css" />
    <link rel="canonical" href="https://siliconlabs.github.io/UnifySDK/applications/zpc/how_to_implement_zwave_command_classes.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/js/charenc.js"></script>
        <script src="../../_static/js/crypt.js"></script>
        <script src="../../_static/js/sha1.js"></script>
        <script src="../../_static/js/html5-qrcode.min.js"></script>
        <script src="../../_static/js/qr_code_scanner.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="How to interact with clusters" href="how_to_interact_with_clusters.html" />
    <link rel="prev" title="UAM maps for the ZPC" href="how_to_write_uam_files_for_the_zpc.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../doc/introduction.html" class="icon icon-home"> Unify
            <img src="../../_static/silicon-labs-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                ver_1.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../doc/introduction.html">Unify Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/getting_started_unify.html">Getting Started with Unify</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../doc/UnifySDK.html">Unify Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/unify_framework_services.html">Framework Services</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../doc/protocol_controllers.html">Protocol Controllers</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../doc/protocol/zwave/zpc_introduction.html">Z-Wave (ZPC)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="readme_user.html">ZPC User’s Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="readme_certification.html">ZPC - Z-Wave (certification) Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../doc/readme_debug.html">ZPC Debugging Guide</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Guideline for implementing Command Classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-the-z-wave-command-class-attribute-state-data-model">Defining the Z-Wave Command Class attribute state data model</a></li>
<li class="toctree-l4"><a class="reference internal" href="#create-the-data-model-in-the-attribute-store">Create the data model in the Attribute Store</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attribute-definition">Attribute definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#attribute-registration">Attribute registration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#write-the-logic-of-the-command-class">Write the logic of the command class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#base-skeleton-creation">Base skeleton creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mapping-z-wave-to-dotdot-ucl-with-uam-file">Mapping Z-Wave to Dotdot UCL with .uam file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#map-z-wave-attribute-to-clusters-attributes">Map Z-Wave attribute to clusters attributes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quirks">Quirks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unit-testing">Unit Testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#z-wave-self-certification-with-the-compliance-test-tool-ctt">Z-Wave Self-Certification with the Compliance Test Tool (CTT)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setup-the-ctt-project">Setup the CTT project</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run-the-tests">Run the tests</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="how_to_write_uam_files_for_the_zpc.html">UAM maps for the ZPC</a></li>
<li class="toctree-l3"><a class="reference internal" href="how_to_interact_with_clusters.html">How to interact with clusters</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc/supported_command_classes.html">Supported Z-Wave Command Classes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../doc/protocol/zigbee/zigpc_introduction.html">Zigbee (ZigPC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../doc/multiprotocol.html">Multiprotocol Host Software</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../doc/protocol/matter/matter_mpc.html">Matter Protocol Controller (MPC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../doc/protocol/aox/aox_introduction.html">Bluetooth AoX (AoXPC)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/unify_iot_services.html">IoT Services</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../doc/getting_started_as_developer.html">Getting Started as a Developer</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../doc/unify_specifications/index.html">Unify Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/standards/known-abbreviations.html">Known Abbreviations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc/license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../doc/introduction.html">Unify</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <script>
    $(".wy-side-scroll").append("<div class='github-button'><iframe src='https://ghbtns.com/github-btn.html?user=SiliconLabs&repo=UnifySDK&type=watch&count=true&size=large&v=2' allowtransparency='true' frameborder='0' scrolling='0' width='170' height='30'></iframe></div>");
</script>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="guideline-for-implementing-command-classes">
<h1>Guideline for implementing Command Classes<a class="headerlink" href="#guideline-for-implementing-command-classes" title="Permalink to this heading"></a></h1>
<p>This guide is meant to guide you to implement a new Z-Wave command class
in Unify. We’ll go trough step by step following a real example :
implementing the Sound Switch command class.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#defining-the-z-wave-command-class-attribute-state-data-model" id="id8">Defining the Z-Wave Command Class attribute state data model</a></p></li>
<li><p><a class="reference internal" href="#create-the-data-model-in-the-attribute-store" id="id9">Create the data model in the Attribute Store</a></p></li>
<li><p><a class="reference internal" href="#attribute-definition" id="id10">Attribute definition</a></p></li>
<li><p><a class="reference internal" href="#attribute-registration" id="id11">Attribute registration</a></p></li>
<li><p><a class="reference internal" href="#write-the-logic-of-the-command-class" id="id12">Write the logic of the command class</a></p></li>
<li><p><a class="reference internal" href="#base-skeleton-creation" id="id13">Base skeleton creation</a></p></li>
<li><p><a class="reference internal" href="#implementation" id="id14">Implementation</a></p>
<ul>
<li><p><a class="reference internal" href="#global-handler" id="id15">Global handler</a></p></li>
<li><p><a class="reference internal" href="#initialize-attributes" id="id16">Initialize attributes</a></p></li>
<li><p><a class="reference internal" href="#get-set-command" id="id17">Get/Set command</a></p></li>
<li><p><a class="reference internal" href="#report-callback" id="id18">Report callback</a></p></li>
<li><p><a class="reference internal" href="#testing-our-implementation" id="id19">Testing our implementation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mapping-z-wave-to-dotdot-ucl-with-uam-file" id="id20">Mapping Z-Wave to Dotdot UCL with .uam file</a></p></li>
<li><p><a class="reference internal" href="#map-z-wave-attribute-to-clusters-attributes" id="id21">Map Z-Wave attribute to clusters attributes</a></p>
<ul>
<li><p><a class="reference internal" href="#on-off-cluster" id="id22">On/Off cluster</a></p></li>
<li><p><a class="reference internal" href="#level-cluster" id="id23">Level cluster</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#quirks" id="id24">Quirks</a></p></li>
<li><p><a class="reference internal" href="#unit-testing" id="id25">Unit Testing</a></p>
<ul>
<li><p><a class="reference internal" href="#add-test-file-to-cmake" id="id26">Add test file to CMake</a></p></li>
<li><p><a class="reference internal" href="#base-test-skeleton" id="id27">Base test skeleton</a></p></li>
<li><p><a class="reference internal" href="#test-report-z-wave-function" id="id28">Test report Z-Wave function</a></p></li>
<li><p><a class="reference internal" href="#test-get-set-z-wave-function" id="id29">Test get/set Z-Wave function</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#z-wave-self-certification-with-the-compliance-test-tool-ctt" id="id30">Z-Wave Self-Certification with the Compliance Test Tool (CTT)</a></p></li>
<li><p><a class="reference internal" href="#prerequisites" id="id31">Prerequisites</a></p></li>
<li><p><a class="reference internal" href="#setup-the-ctt-project" id="id32">Setup the CTT project</a></p></li>
<li><p><a class="reference internal" href="#run-the-tests" id="id33">Run the tests</a></p></li>
</ul>
</div>
<p>The following schema shows you a top level view of all the components we
are using :</p>
<figure class="align-center">
<img alt="Overview" src="../../_images/zwave_command_class_integration.png" />
</figure>
<ul class="simple">
<li><p>The Z-Wave controller handles the Z-Wave commands and update the
attribute store if needed.</p></li>
<li><p>The UCL updates the Attribute Store though commands.</p></li>
<li><p>The Attribute Store send events to :</p>
<ul>
<li><p>The attributes monitored by the Z-Wave controller</p></li>
<li><p>The attributes monitored by the UCL that triggers MQTT Broker
messages.</p></li>
</ul>
</li>
<li><p>The .uam files allow to automatically update UCL attributes when
Z-Wave attributes changes and vice versa.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want the simplest example of a command class
implementation you can look at the Alarm Sensor command class.</p>
</div>
<section id="defining-the-z-wave-command-class-attribute-state-data-model">
<h2>Defining the Z-Wave Command Class attribute state data model<a class="headerlink" href="#defining-the-z-wave-command-class-attribute-state-data-model" title="Permalink to this heading"></a></h2>
<p>The first step is to define the data model of the Z-Wave Command Class
attributes state. The Z-Wave command class specification is the better starting point.
If you don’t have access to it the Z-Wave PC Controller tool can show you each commands for
each command class, but without specifics.
The goal is to look at different commands (get/set/report) and see which attributes are
worth saving.</p>
<p>A good approach is to also make sure that you can self-certify your
command class with the Compliance Test Tool (CTT) proposed by the Z-Wave
alliance. You can find out more about that in the <a class="reference internal" href="#z-wave-self-certification-with-the-compliance-test-tool-ctt"><span class="std std-ref">Z-Wave Compliance
Test Tool (CTT)
section</span></a>.
We recommend to validate your implementation against the CTT tool if applicable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All commands classes are not available in CTT. You also have to be an <a class="reference external" href="https://z-wavealliance.org/join-z-wave-alliance-now/">alliance member to access the tool</a>.</p>
<p>The <a class="reference external" href="https://sdomembers.z-wavealliance.org/document/dl/1833">Z-Wave End Device Emulator</a> is accessible to anyone
and is able to emulate an End Device and test your implementation against it.</p>
</div>
<figure class="align-center">
<img alt="Sound switch commands" src="../../_images/zwave_command_class_sound_switch_commands.png" />
</figure>
<p>Most of the commands should be already defined in <code class="docutils literal notranslate"><span class="pre">ZW_classcmd.h</span></code>. Not
that this file might not contains all the definitions you need, but you
can look in the GSDK folder that contains the same file but more up to
date. Simply copy the attributes and commands you need in the local
<code class="docutils literal notranslate"><span class="pre">ZW_classcmd.h</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Don’t replace the new file by the old one as you might have
some incompatibilities with the current command classes.</p>
</div>
<p>Based on the commands we need the following attributes :</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 29%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Attribute</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Associated command</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Tone number</p></td>
<td><p>Supported tone
number count</p></td>
<td><p>Tones Number</p></td>
</tr>
<tr class="row-odd"><td><p>Configured
volume</p></td>
<td><p>Current default
volume on the
device</p></td>
<td><p>Configuration</p></td>
</tr>
<tr class="row-even"><td><p>Configured tone</p></td>
<td><p>Current default
tone on the device</p></td>
<td><p>Configuration</p></td>
</tr>
<tr class="row-odd"><td><p>Tone Identifier</p></td>
<td><p>One for each tone
number reported</p></td>
<td><p>Tone Info</p></td>
</tr>
<tr class="row-even"><td><p>Tone info name</p></td>
<td><p>Tone Description
(under each Tone
Identifier)</p></td>
<td><p>Tone Info</p></td>
</tr>
<tr class="row-odd"><td><p>Tone info
duration</p></td>
<td><p>Tone Duration
(under each Tone
Identifier)</p></td>
<td><p>Tone Info</p></td>
</tr>
<tr class="row-even"><td><p>Play</p></td>
<td><p>The tone ID that
the device plays.
0 to stop, 255 to
play the default
tone
(Configuration
command) and 1-254
to play a specific
tone</p></td>
<td><p>Play</p></td>
</tr>
</tbody>
</table>
<p>With those attributes we cover all the commands needs. The following
schema illustrates the attributes we use in our Sound Switch command
class implementation :</p>
<figure class="align-default">
<img alt="Sound Switch" src="../../_images/attribute_store_sound_switch.png" />
</figure>
<p>Each attribute in our Attribute Store triggers Z-Wave commands.</p>
<p>We use a <code class="docutils literal notranslate"><span class="pre">TONE_INFO_IDENTIFIER</span></code> as a parent of <code class="docutils literal notranslate"><span class="pre">TONE_INFO_DURATION</span></code>
and <code class="docutils literal notranslate"><span class="pre">TONE_INFO_NAME</span></code> because they are directly related. The Z-Wave
specification tells us to send a <code class="docutils literal notranslate"><span class="pre">Tone</span> <span class="pre">Info</span> <span class="pre">Get</span></code> for each reported
Tones Number. This way we can create as many <code class="docutils literal notranslate"><span class="pre">TONE_INFO_IDENTIFIER</span></code>
node as needed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TONE_INFO_IDENTIFIER</span></code> triggers a Tone Info command while
<code class="docutils literal notranslate"><span class="pre">CONFIGURED_DEFAULT_TONE_IDENTIFIER</span></code> triggers a Configuration command.</p>
<p>In the attribute store attributes has two states : defined and reported.</p>
<ul class="simple">
<li><p>If the reported value is missing, the controller sends a GET command
to gather the reported value.</p></li>
<li><p>If the defined value is set, the controller sends a SET command to
set the desired value.</p></li>
</ul>
<p>This mapping is explained in <a class="reference internal" href="#get-set-command"><span class="std std-ref">Get/Set command
section</span></a>.</p>
</section>
<section id="create-the-data-model-in-the-attribute-store">
<h2>Create the data model in the Attribute Store<a class="headerlink" href="#create-the-data-model-in-the-attribute-store" title="Permalink to this heading"></a></h2>
<p>After defining the data model, the next step is to define the type of
each node in the attribute store.</p>
<p>In
<code class="docutils literal notranslate"><span class="pre">applications\zpc\components\zpc_attribute_store\include\command_class_types</span></code>
create an header that defines the types used in command class
implementation. The naming convention is
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_{COMMAND_CLASS_NAME}.h</span></code></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">///&gt; Tone identifier. uint8_t</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sound_switch_tone_id_t</span><span class="p">;</span>
<span class="c1">///&gt; Tone duration. uint16_t</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">sound_switch_tone_duration_t</span><span class="p">;</span>

<span class="c1">///&gt; Volume representation. uint8_t</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sound_switch_volume_t</span><span class="p">;</span>
</pre></div>
</div>
<p>You might want to update this file as you are writing the logic. Here we
defined 3 attributes we use often in the Sound Switch class : the tone
identifier, the tone duration and the volume.</p>
</section>
<section id="attribute-definition">
<span id="attribute-id-in-the-attribute-store"></span><h2>Attribute definition<a class="headerlink" href="#attribute-definition" title="Permalink to this heading"></a></h2>
<p>Then we need to create the attributes of command class to register them
later in the attribute store. This is done in the
<code class="docutils literal notranslate"><span class="pre">attribute_store_defined_attribute_types.h</span></code> header.</p>
<p>To add an attribute you can use the <code class="docutils literal notranslate"><span class="pre">DEFINE_ATTRIBUTE</span></code> macro. Each
attribute should have an unique ID on 16 bits :</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>[COMMAND_CLASS_ID][UNIQUE_ATTRIBUTE_ID]
[0x79][0x01]
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">COMMAND_CLASS_ID</span></code> is the command class ID (found in
<code class="docutils literal notranslate"><span class="pre">ZW_classcmd.h</span></code>) and <code class="docutils literal notranslate"><span class="pre">UNIQUE_ATTRIBUTE_ID</span></code> is an arbitrary and
unique ID to the command class.</p>
<p>The first attribute you have to declare is the supported version :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// zwave_cc_version_t</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span>
<span class="w">                 </span><span class="n">ZWAVE_CC_VERSION_ATTRIBUTE</span><span class="p">(</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ZWAVE_CC_VERSION_ATTRIBUTE</span></code> macro set the unique attribute ID to
0x01. So you have to start your custom attribute listing to 0x02. We can
define <code class="docutils literal notranslate"><span class="pre">CONFIGURED_DEFAULT_VOLUME</span></code> like :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Configured volume for the Sound Switch</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x02</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span></code> has
an ID of <code class="docutils literal notranslate"><span class="pre">0x7902</span></code>. This is used latter for mapping the attribute store
Z-Wave attributes to the Dot Dot model.</p>
<p>A complete definition of our classes attribute can be found bellow :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////////////////////</span>
<span class="c1">// Sound Switch Command Class</span>
<span class="c1">///&lt; This represents the version of the Sound Switch Command class.</span>
<span class="c1">/// zwave_cc_version_t</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span>
<span class="w">                 </span><span class="n">ZWAVE_CC_VERSION_ATTRIBUTE</span><span class="p">(</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">))</span>
<span class="c1">// Configured volume for the Sound Switch</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x02</span><span class="p">))</span>
<span class="c1">// Configured tone for the Sound Switch</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span>
<span class="w">  </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">  </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x03</span><span class="p">))</span>
<span class="c1">// Number of tones supported by the receiving node</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x04</span><span class="p">))</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x05</span><span class="p">))</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_DURATION_IN_SECONDS</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x06</span><span class="p">))</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_NAME</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x07</span><span class="p">))</span>
<span class="c1">// Command is used to instruct a supporting node to play (or stop playing) a tone.</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span><span class="p">,</span>
<span class="w">                 </span><span class="p">((</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x08</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="attribute-registration">
<h2>Attribute registration<a class="headerlink" href="#attribute-registration" title="Permalink to this heading"></a></h2>
<p>Now that we have all our attributes defined we must register them in the
attribute store. We can do that in the
<code class="docutils literal notranslate"><span class="pre">zpc_attribute_store_type_registration.cpp</span></code> file.</p>
<p>You just need to add an new entry with :</p>
<ol class="arabic simple">
<li><p>Our attribute store name defined in
<code class="docutils literal notranslate"><span class="pre">attribute_store_defined_attribute_types.h</span></code></p></li>
<li><p>A const String description of the attribute</p></li>
<li><p>The parent node. In most cases it is the <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code>,
but you can set it to another attribute if needed. The more
attributes we put under the endpoint the poorer performance.</p></li>
<li><p>The type of the attribute. The complete enum can be found in
<code class="docutils literal notranslate"><span class="pre">components/uic_attribute_store/include/attribute_store_type_registration.h</span></code>.
If set the engine validates the value you try to write in it and
raise an error if types are incompatible.</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Sound Switch Version&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
</pre></div>
</div>
<p>The full sample can be found bellow :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="c1">//         Sound Switch Command Class attributes</span>
<span class="c1">/////////////////////////////////////////////////////////////////////</span>
<span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Sound Switch Version&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
<span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Configured Default Volume&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
<span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Configured Default Tone Identifier&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
<span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Tones Number&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>

<span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Tone Info Identifier&quot;</span><span class="p">,</span><span class="w">  </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span><span class="w">   </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>

<span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_DURATION_IN_SECONDS</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Tone Info Duration (seconds)&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span><span class="w">   </span><span class="n">U16_STORAGE_TYPE</span><span class="p">},</span>
<span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_NAME</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;Tone Info Name&quot;</span><span class="p">,</span><span class="w">   </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span><span class="w">   </span><span class="n">C_STRING_STORAGE_TYPE</span><span class="p">},</span>

<span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Tone Play&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w"> </span><span class="n">U8_STORAGE_TYPE</span><span class="p">},</span>
</pre></div>
</div>
<p>You can see that
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_DURATION_IN_SECONDS</span></code>
and <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_NAME</span></code> parents are
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span></code> and not
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code>. This is because those parameters depends
directly on the value
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span></code> and we do
not want to surcharge our endpoint tree.</p>
</section>
<section id="write-the-logic-of-the-command-class">
<h2>Write the logic of the command class<a class="headerlink" href="#write-the-logic-of-the-command-class" title="Permalink to this heading"></a></h2>
</section>
<section id="base-skeleton-creation">
<h2>Base skeleton creation<a class="headerlink" href="#base-skeleton-creation" title="Permalink to this heading"></a></h2>
<p>Now that our attributes are known to the Attribute Store we can start
implementing our command class logic.</p>
<p>You can create a new header in
<code class="docutils literal notranslate"><span class="pre">applications\zpc\components\zwave_command_classes\src</span></code> with the
following name pattern : <code class="docutils literal notranslate"><span class="pre">zwave_command_class_{COMMAND_CLASS_NAME}.h</span></code>
where <code class="docutils literal notranslate"><span class="pre">{COMMAND_CLASS_NAME}</span></code> is your Z-Wave command class name. In our
example our new header is : <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch.h</span></code></p>
<p>Repeat this process for the source file. Note that you can use either
<code class="docutils literal notranslate"><span class="pre">.c</span></code> or <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> file as long as your header is <code class="docutils literal notranslate"><span class="pre">C</span></code> compatible. For
our example we create the file <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch.c</span></code>.</p>
<p>We need to add the source file to the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> located in
<code class="docutils literal notranslate"><span class="pre">applications\zpc\components\zwave_command_classes\</span></code> :</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_library</span><span class="p">(</span>
<span class="w">  </span><span class="s">zwave_command_classes</span>
<span class="w">  </span><span class="s">platform/-{COMPATIBLE_PLATFORM}/platform_date_time.c</span>
<span class="w">  </span><span class="s">platform/-{COMPATIBLE_PLATFORM}/platform_exec.c</span>

<span class="w">  </span><span class="s">//...</span>

<span class="w">  </span><span class="s">src/zwave_command_class_sound_switch.c</span>

<span class="w">  </span><span class="s">//...</span>

<span class="w">  </span><span class="s">src/zwave_command_class_transport_service.c</span><span class="p">)</span>
</pre></div>
</div>
<p>This ensures that our new file is correctly added to the build system.
No need to include the header.</p>
<p>We recommend to fill your new header file with the contents of existing
command classes header. Doxygen documentation is based on the structure
of this header to create the section about the new command class.</p>
<p>We need at least one function to act as an entry point. The naming
convention is <code class="docutils literal notranslate"><span class="pre">zwave_command_class_{class_name}_init</span></code>, where
<code class="docutils literal notranslate"><span class="pre">{class_name}</span></code> is the current Z-Wave class name. In our example we
declare the function <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_init</span></code>. Our
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch.h</span></code> should look like that :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @defgroup zwave_command_class_sound_switch</span>
<span class="cm"> * @brief Sound Switch Command Class handlers and control function</span>
<span class="cm"> *</span>
<span class="cm"> * This module implement some of the functions to control the</span>
<span class="cm"> * Sound Switch Command Class</span>
<span class="cm"> *</span>
<span class="cm"> * @{</span>
<span class="cm"> */</span>

<span class="cp">#ifndef ZWAVE_COMMAND_CLASS_SOUND_SWITCH_H</span>
<span class="cp">#define ZWAVE_COMMAND_CLASS_SOUND_SWITCH_H</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sl_status.h&quot;</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#endif</span>

<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_init</span><span class="p">();</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif  </span><span class="c1">//ZWAVE_COMMAND_CLASS_SOUND_SWITCH_H</span>
<span class="cm">/** @} end zwave_command_class_sound_switch */</span>
</pre></div>
</div>
<p>For now we fill our source file with an empty definition :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// System</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_sound_switch.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_classes_utils.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ZW_classcmd.h&quot;</span>

<span class="c1">// Includes from other ZPC Components</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_indices.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_handler.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_version_types.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zpc_attribute_store_network_helper.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_defined_attribute_types.h&quot;</span>

<span class="c1">// Unify</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_resolver.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_helper.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sl_log.h&quot;</span>

<span class="cp">#define LOG_TAG &quot;zwave_command_class_sound_switch&quot;</span>


<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that some header were also added to the skeleton. They are here for
later, but feel free to remove the unused ones when you are finished.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">LOG_TAG</span></code> should be used when calling <code class="docutils literal notranslate"><span class="pre">sl_log_xxx()</span></code> function
(<code class="docutils literal notranslate"><span class="pre">sl_log_warning(LOG_TAG,</span> <span class="pre">&quot;My</span> <span class="pre">warning&quot;);</span></code>). This ensure that all
messages that comes from this class is under the same tag. This is
useful to filter logs based on the component we are interested in.</p>
<p>Now that we have our entry point we have to call it in the
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_fixt.c</span></code> file. First we need to include our header
and then call it from the function <code class="docutils literal notranslate"><span class="pre">zwave_command_classes_init()</span></code> :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_sound_switch.h&quot;</span>
<span class="c1">// ...</span>

<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_classes_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">sl_status_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Special handlers:</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">zwave_command_class_granted_keys_resolver_init</span><span class="p">();</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">zwave_command_class_node_info_resolver_init</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Do not abort initialization of other CCs if one fails.</span>
<span class="w">  </span><span class="c1">// Command Class handlers</span>
<span class="w">  </span><span class="c1">// Note: AGI should stay first, it allows others to register commands.</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">zwave_command_class_agi_init</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">zwave_command_class_sound_switch_init</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="n">zwave_command_handler_print_info</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now that our skeleton is up and running we can start implement our new
command class.</p>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this heading"></a></h2>
<section id="global-handler">
<h3>Global handler<a class="headerlink" href="#global-handler" title="Permalink to this heading"></a></h3>
<p>Let’s populate our initialization function
(<code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_init</span></code>). The first thing to do is to
add an command handler :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">zwave_command_handler_t</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">support_handler</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">minimal_scheme</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ZWAVE_CONTROLLER_ENCAPSULATION_NONE</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">manual_security_validation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">command_class</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">version</span><span class="w">                    </span><span class="o">=</span><span class="w"> </span><span class="n">SOUND_SWITCH_VERSION</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">command_class_name</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Sound Switch&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">comments</span><span class="w">                   </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">zwave_command_handler_register_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This snippet registers the handler for your Z-Wave command class. The
handler options are :</p>
<ul class="simple">
<li><p><strong>support_handler</strong> : Support handler for the Z-Wave command class.
This allows you to react when receiving Get/Set commands. Some
example of this handler can be found in already implemented command
classes (<code class="docutils literal notranslate"><span class="pre">indicator</span></code>, <code class="docutils literal notranslate"><span class="pre">powerlevel</span></code>, <code class="docutils literal notranslate"><span class="pre">inclusion_controller</span></code>, …).</p></li>
<li><p><strong>control_handler</strong> : Control handler for the Z-Wave command class.
This allows you to react to Report commands.</p></li>
<li><p><strong>minimal_scheme</strong> : The minimal security level which this command is
supported on. This is ignored for the control_handler.</p></li>
<li><p><strong>manual_security_validation</strong> : Use manual-security filtering for
incoming frames. If set to true, the command class dispatch handler
send frames to the handler without validating their security level.If
set to false, the command class handler can assume that the frame has
been received at an approved security level.</p></li>
<li><p><strong>command_class</strong> : command class ID that this handler implements</p></li>
<li><p><strong>version</strong> : Maximal version supported of the command class</p></li>
<li><p><strong>command_class_name</strong> : Description of the current command class (no
need to include “Command class”)</p></li>
<li><p><strong>comments</strong> : Comments about the implementation. It is printed to
the log when starting the zpc component.</p></li>
</ul>
<p>Now that we have an handler, let’s implement the get/set/report command
classes for <code class="docutils literal notranslate"><span class="pre">Configuration</span></code>.</p>
</section>
<section id="initialize-attributes">
<h3>Initialize attributes<a class="headerlink" href="#initialize-attributes" title="Permalink to this heading"></a></h3>
<p>One of the first thing the controller is doing is to update the version
attribute. That’s why the version attribute always has an unique
attribute ID of 0x01. You can subscribe to changes to an attribute with
the <code class="docutils literal notranslate"><span class="pre">attribute_store_register_callback_by_type</span></code>. This is also the best
place to initialize your attributes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">attribute_store_register_callback_by_type</span></code> function takes 2
arguments :</p>
<ul class="simple">
<li><p>A callback function that takes two arguments :</p>
<ul>
<li><p><strong>attribute_store_node_t</strong> <em>updated_node</em> : The node ID of the
attribute</p></li>
<li><p><strong>attribute_store_change_t</strong> <em>change</em> : Type of change</p></li>
</ul>
</li>
<li><p>The attribute to monitor. In our case
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span></code>.</p></li>
</ul>
<p>We can call this function in our entrypoint
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_init</span></code> before the handler definition
:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">attribute_store_register_callback_by_type</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_on_version_attribute_update</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="c1">// handler definition</span>
<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">zwave_command_handler_register_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This calls
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_on_version_attribute_update</span></code> on each
update of <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span></code>.</p>
<p>Our implementation of
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_on_version_attribute_update</span></code> look
like this :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_on_version_attribute_update</span><span class="p">(</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">updated_node</span><span class="p">,</span><span class="w"> </span><span class="n">attribute_store_change_t</span><span class="w"> </span><span class="n">change</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">change</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_DELETED</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">zwave_cc_version_t</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">attribute_store_get_reported</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">));</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">version</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">endpoint_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_first_parent_with_type</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span>
<span class="w">                                                 </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// The order of the attribute matter since it defines the order of the</span>
<span class="w">  </span><span class="c1">// Z-Wave get command order.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">attribute_store_type_t</span><span class="w"> </span><span class="n">attributes</span><span class="p">[]</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span>
<span class="w">      </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">      </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">      </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span><span class="p">,</span>
<span class="w">      </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span><span class="p">};</span>

<span class="w">  </span><span class="n">attribute_store_add_if_missing</span><span class="p">(</span><span class="n">endpoint_node</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">attributes</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">COUNT_OF</span><span class="p">(</span><span class="n">attributes</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">change</span></code> attribute tells you which operation is currently
performed on this attribute (deleted, added or modified). We then try to
get the version from the attribute store. It is possible that we don’t
have the value reported yet, so we simply return and do nothing. If we
have the version we can create the base structure of our attributes with
the <code class="docutils literal notranslate"><span class="pre">attribute_store_add_if_missing</span></code> function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We don’t define our attributes under the
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_INFO_IDENTIFIER</span></code>, they
are created once they are reported. The
<code class="docutils literal notranslate"><span class="pre">attribute_store_set_child_reported()</span></code> function adds the attribute
in the tree if they are missing. You can check the details in
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_handle_tone_info_report</span></code>
function.</p>
</div>
</section>
<section id="get-set-command">
<span id="id1"></span><h3>Get/Set command<a class="headerlink" href="#get-set-command" title="Permalink to this heading"></a></h3>
<p>We’ll take the example of following commands : <code class="docutils literal notranslate"><span class="pre">CONFIGURATION_GET</span></code> and
<code class="docutils literal notranslate"><span class="pre">CONFIGURATION_SET</span></code></p>
<p>We can easily map the set/get function to an attribute of the Attribute
Store. Here we want to map the previously defined attributes :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span></code></p></li>
</ul>
<p>Since they are both used in argument of the <code class="docutils literal notranslate"><span class="pre">Z-Wave</span> <span class="pre">set</span></code>.</p>
<p>We can do this with the <code class="docutils literal notranslate"><span class="pre">attribute_resolver_register_rule</span></code> function
that takes 3 arguments :</p>
<ul class="simple">
<li><p>The attribute store identifier</p></li>
<li><p>The associated callback for set function (can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p></li>
<li><p>The associated callback for get function (can be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)</p></li>
</ul>
<p>This function listen to changes on the given attributes and call the
get/set functions accordingly :</p>
<ul>
<li><p><strong>Get function</strong> is called if we <em>don’t</em> have a reported value.</p>
<blockquote>
<div><ul class="simple">
<li><p>You can test this behavior with the ZPC command <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_undefine_reported</span> <span class="pre">NodeID</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>Set function</strong> is called on desired value change.</p>
<blockquote>
<div><ul class="simple">
<li><p>You can test this behavior with the ZPC command <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_set_desired</span> <span class="pre">NodeID</span></code>.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>ZPC CLI is treated in the <a class="reference internal" href="#testing-our-implementation"><span class="std std-ref">Testing our
implementation</span></a> section.</p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">attribute_resolver_register_rule</span><span class="p">(</span>
<span class="w">  </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">  </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_set</span><span class="p">,</span>
<span class="w">  </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_get</span><span class="p">);</span>

<span class="n">attribute_resolver_register_rule</span><span class="p">(</span>
<span class="w">  </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">  </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_set</span><span class="p">,</span>
<span class="w">  </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_get</span><span class="p">);</span>
</pre></div>
</div>
<p>Each attribute can have only one rule, but it is not necessary to
register a rule for all the attributes. A rule is necessary only for
attributes that are used from a set or/and get function.</p>
<p>The callbacks must take 3 arguments :</p>
<ol class="arabic simple">
<li><p><strong>attribute_store_node_t</strong> <em>node</em> : Current node ID of the attribute
that trigger this callback.</p></li>
<li><p><strong>int8_t</strong> <em>*frame</em> : A pointer to the frame that will be sent. It
has to be filled by the callback.</p></li>
<li><p><strong>uint16_t</strong> <em>*frame_length</em> : A pointer to the frame length. It has
to be filled by the callback.</p></li>
</ol>
<p>The node ID can be visualized with the ZPC commands
<code class="docutils literal notranslate"><span class="pre">attribute_store_log_xxx</span></code>. Here is a truncated result of
<code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Tone</span></code> :</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>(1) Root node .................................................................     &lt;&gt; (&lt;&gt;)
    │───(2) HomeID ............................................................ [58,27,e5,fc] (&lt;&gt;)
    │   │───(8) NodeID ........................................................      3 (&lt;&gt;)
    │   │   │───(9) Endpoint ID ...............................................      0 (&lt;&gt;)
    │   │   │   │───(80) Configured Default Tone Identifier ...................      4 (&lt;&gt;)
    │   │   │   │───(81) Tones Number .........................................     30 (&lt;&gt;)
    │   │   │   │───(84) Tone Info Identifier .................................      4 (&lt;&gt;)
    │   │   │   │   │───(211) Tone Info Duration ..............................      1 (&lt;&gt;)
    │   │   │   │   │───(212) Tone Info Name .................................. &quot;04 Electric Apartment Buzzer&quot; (&lt;&gt;)
    │   │   │   │───(85) Tone Play ............................................      0 (&lt;&gt;)
</pre></div>
</div>
<p>The node ID is represented by the number between parenthesis. The <em>node</em>
argument has the ID of the monitored attribute. The first value correspond
to the reported value, and the value between parenthesis are the desired
value (<code class="docutils literal notranslate"><span class="pre">(&lt;&gt;)</span></code> means no desired value).</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Tone</span> <span class="pre">Info</span> <span class="pre">Identifier</span></code> attribute is bonded to a get only
function. That means if the reported value is undefined (e.g at
startup with an empty attribute store), this get callback will have
its <em>node</em> argument set to 81.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Configured</span> <span class="pre">Default</span> <span class="pre">Tone</span> <span class="pre">Identifier</span></code> attribute is bonded to
both get and set function. If something changes, the callback (set or
get) will have its <em>node</em> argument set to 80.</p></li>
</ul>
<p>The get function is the most straight forward : it doesn’t require any
argument we only need to send the frame.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_configuration_get</span><span class="p">(</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame_length</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">node</span><span class="p">;</span><span class="w">  </span><span class="c1">// unused.</span>
<span class="w">  </span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_GET_FRAME</span><span class="w"> </span><span class="o">*</span><span class="n">get_frame</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_GET_FRAME</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">frame</span><span class="p">;</span>
<span class="w">  </span><span class="n">get_frame</span><span class="o">-&gt;</span><span class="n">cmdClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">;</span>
<span class="w">  </span><span class="n">get_frame</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">SOUND_SWITCH_CONFIGURATION_GET</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">frame_length</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_GET_FRAME</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The set function in the other hand is less straight forward : we have to
get the elements in the attribute store and give to the <code class="docutils literal notranslate"><span class="pre">Z-Wave</span> <span class="pre">set</span></code>
command.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_configuration_set</span><span class="p">(</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame_length</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">sound_switch_configuration_t</span><span class="w"> </span><span class="n">configuration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">endpoint_id_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_first_parent_with_type</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">);</span>

<span class="w">  </span><span class="n">get_configuration</span><span class="p">(</span><span class="n">endpoint_id_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">configuration</span><span class="p">);</span>

<span class="w">  </span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_SET_FRAME</span><span class="w"> </span><span class="o">*</span><span class="n">set_frame</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_SET_FRAME</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">frame</span><span class="p">;</span>
<span class="w">  </span><span class="n">set_frame</span><span class="o">-&gt;</span><span class="n">cmdClass</span><span class="w">              </span><span class="o">=</span><span class="w"> </span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">;</span>
<span class="w">  </span><span class="n">set_frame</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="w">                   </span><span class="o">=</span><span class="w"> </span><span class="n">SOUND_SWITCH_CONFIGURATION_SET</span><span class="p">;</span>
<span class="w">  </span><span class="n">set_frame</span><span class="o">-&gt;</span><span class="n">volume</span><span class="w">                </span><span class="o">=</span><span class="w"> </span><span class="n">configuration</span><span class="p">.</span><span class="n">volume</span><span class="p">;</span>
<span class="w">  </span><span class="n">set_frame</span><span class="o">-&gt;</span><span class="n">defaultToneIdentifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">configuration</span><span class="p">.</span><span class="n">tone</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">frame_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ZW_SOUND_SWITCH_CONFIGURATION_SET_FRAME</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can have a peek in the current attribute store by executing
<code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Tone</span></code> (more info on CLI in the
section <a class="reference internal" href="#testing-our-implementation"><span class="std std-ref">Testing our implementation</span></a>).
The following sample also has the result of
<code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Volume</span></code> :</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>│   │   │───(9) Endpoint ID ...............................................      0 (&lt;&gt;)
│   │   │   │───(75) Configured Default Volume ............................      1 (&lt;&gt;)
│   │   │   │───(80) Configured Default Tone Identifier ...................      4 (&lt;&gt;)
│   │   │   │───(81) Tones Number .........................................     1 (&lt;&gt;)
|   │   │   │   │───(84) Tone Info Identifier .................................      1 (&lt;&gt;)
|   │   │   │   │   │───(211) Tone Info Duration ..............................      10 (&lt;&gt;)
|   │   │   │   │   │───(212) Tone Info Name .................................. &quot;01 Electric Apartment Buzzer&quot; (&lt;&gt;)
|   |   │   │   │───(89) Tone Info Identifier .................................      2 (&lt;&gt;)
|   │   │   │   │   │───(214) Tone Info Duration ..............................      1312 (&lt;&gt;)
|   │   │   │   │   │───(215) Tone Info Name .................................. &quot;02 Alarm Buzzer&quot; (&lt;&gt;)
│   │   │   │───(85) Tone Play ............................................      1 (&lt;&gt;)
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">node</span></code> argument here is set to either the node ID of
<code class="docutils literal notranslate"><span class="pre">Configured</span> <span class="pre">Default</span> <span class="pre">Volume</span></code> (75) or
<code class="docutils literal notranslate"><span class="pre">Configured</span> <span class="pre">Default</span> <span class="pre">Tone</span> <span class="pre">Identifier</span></code> (80).</p>
<p>However we need to access both of those values. To do so we get
<code class="docutils literal notranslate"><span class="pre">Endpoint</span> <span class="pre">ID</span></code> node ID : this allows us to have access to all its
children.</p>
<p>The function
<code class="docutils literal notranslate"><span class="pre">attribute_store_get_first_parent_with_type(node,</span> <span class="pre">ATTRIBUTE_ENDPOINT_ID)</span></code>
searches for the first parent with <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code> type : here
it is the node (9).</p>
<p>Once we have the parent node ID, we can pass it to the
<code class="docutils literal notranslate"><span class="pre">get_configuration()</span></code> function that fetches the information we need :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sound_switch_configuration</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sound_switch_volume_t</span><span class="w"> </span><span class="n">volume</span><span class="p">;</span>
<span class="w">  </span><span class="n">sound_switch_tone_id_t</span><span class="w"> </span><span class="n">tone</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">sound_switch_configuration_t</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_configuration</span><span class="p">(</span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">state_node</span><span class="p">,</span>
<span class="w">                              </span><span class="n">sound_switch_configuration_t</span><span class="w"> </span><span class="o">*</span><span class="n">configuration</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">volume_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_first_child_by_type</span><span class="p">(</span><span class="n">state_node</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">);</span>

<span class="w">  </span><span class="n">sl_status_t</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_desired_else_reported</span><span class="p">(</span><span class="n">volume_node</span><span class="p">,</span>
<span class="w">                              </span><span class="o">&amp;</span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">volume</span><span class="p">,</span>
<span class="w">                              </span><span class="k">sizeof</span><span class="p">(</span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">volume</span><span class="p">));</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sl_log_warning</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Can&#39;t get CONFIGURED_DEFAULT_VOLUME from attribute store. Value set to 0.&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">tone_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_first_child_by_type</span><span class="p">(</span><span class="n">state_node</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">);</span>

<span class="w">  </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_desired_else_reported</span><span class="p">(</span><span class="n">tone_node</span><span class="p">,</span>
<span class="w">                             </span><span class="o">&amp;</span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">tone</span><span class="p">,</span>
<span class="w">                             </span><span class="k">sizeof</span><span class="p">(</span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">tone</span><span class="p">));</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">configuration</span><span class="o">-&gt;</span><span class="n">tone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">sl_log_warning</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Can&#39;t get CONFIGURED_DEFAULT_TONE_IDENTIFIER from attribute store. Value set to 0.&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">attribute_store_get_first_child_by_type()</span></code> function fetches the node
ID of given type. Once we have the correct node ID, we can fetch its
value with various <code class="docutils literal notranslate"><span class="pre">attribute_store_get_xxx()</span></code> functions. Here we use
<code class="docutils literal notranslate"><span class="pre">attribute_store_get_desired_else_reported()</span></code> because we want either
the desired or reported value of the attribute. If something goes wrong
the function returns an error code and we set default values.</p>
</section>
<section id="report-callback">
<h3>Report callback<a class="headerlink" href="#report-callback" title="Permalink to this heading"></a></h3>
<p>In the handler we defined previously we’ll need to add a control handler
:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_control_handler</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>The control handler is called when the controller receives a report
command. You can then check which report was sent and update the values
in attribute store.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_control_handler</span><span class="p">(</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">zwave_controller_connection_info_t</span><span class="w"> </span><span class="o">*</span><span class="n">connection_info</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame_data</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">frame_length</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">frame_length</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">COMMAND_INDEX</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_NOT_SUPPORTED</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">frame_data</span><span class="p">[</span><span class="n">COMMAND_INDEX</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">SOUND_SWITCH_CONFIGURATION_REPORT</span><span class="p">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">zwave_command_class_sound_switch_handle_configuration_report</span><span class="p">(</span>
<span class="w">        </span><span class="n">connection_info</span><span class="p">,</span>
<span class="w">        </span><span class="n">frame_data</span><span class="p">,</span>
<span class="w">        </span><span class="n">frame_length</span><span class="p">);</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_NOT_SUPPORTED</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The control handler function takes 3 arguments :</p>
<ul class="simple">
<li><p><strong>zwave_controller_connection_info_t</strong> <em>*connection_info</em> :
Structure holding information about the source and destination when
transmitting and receiving Z-Wave frames. You can retrieve the
endpoint node ID in the attribute store with
<code class="docutils literal notranslate"><span class="pre">zwave_command_class_get_endpoint_node(connection_info)</span></code></p></li>
<li><p><strong>uint8_t</strong> <em>*frame_data</em> : frame received</p></li>
<li><p><strong>uint16_t</strong> <em>frame_length</em> : length of frame received</p></li>
</ul>
<p>We can take a look at the function that process the report frame :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_class_sound_switch_handle_configuration_report</span><span class="p">(</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">zwave_controller_connection_info_t</span><span class="w"> </span><span class="o">*</span><span class="n">connection_info</span><span class="p">,</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">frame_data</span><span class="p">,</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">frame_length</span><span class="p">)</span>
<span class="p">{</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">frame_length</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_FAIL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">endpoint_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">zwave_command_class_get_endpoint_node</span><span class="p">(</span><span class="n">connection_info</span><span class="p">);</span>

<span class="w">  </span><span class="n">sound_switch_volume_t</span><span class="w"> </span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame_data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">volume</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sl_log_warning</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Node reported volume higher than 100&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">attribute_store_set_child_reported</span><span class="p">(</span>
<span class="w">    </span><span class="n">endpoint_node</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">volume</span><span class="p">,</span>
<span class="w">    </span><span class="k">sizeof</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>

<span class="w">  </span><span class="n">sound_switch_tone_id_t</span><span class="w"> </span><span class="n">tone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame_data</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="w">  </span><span class="n">attribute_store_set_child_reported</span><span class="p">(</span>
<span class="w">    </span><span class="n">endpoint_node</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">tone</span><span class="p">,</span>
<span class="w">    </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tone</span><span class="p">));</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s good practice to check the frame length before processing. We
return <code class="docutils literal notranslate"><span class="pre">SL_STATUS_FAIL</span></code> if something goes wrong parsing the frame. The
command handler component uses these return codes to respond to
Supervision Get Commands. Returning <code class="docutils literal notranslate"><span class="pre">SL_STATUS_FAIL</span></code> sends a fail
status therefore be standard compatible. (More information on
Supervision Status code descriptions CC:006C.01.02.11.006 in the Z-Wave
standard).</p>
<p><code class="docutils literal notranslate"><span class="pre">zwave_command_class_get_endpoint_node</span></code> allows us to convert a
<code class="docutils literal notranslate"><span class="pre">zwave_controller_connection_info_t</span></code> into a node ID and returns the
current endpoint node ID. We can use it to update all the attribute we
need.</p>
<figure class="align-center">
<img alt="Report Configuration schema" src="../../_images/zwave_command_class_sound_switch_conf_report.png" />
</figure>
<p>As we can see the report frame has a total size of 4 bits. We can access
the volume part with <code class="docutils literal notranslate"><span class="pre">frame_data[2]</span></code> and the default tone identifier
with <code class="docutils literal notranslate"><span class="pre">frame_data[3]</span></code>. We then mark those attributes as reported. Our
volume attribute is
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span></code> so we
set this value as reported with the value of <code class="docutils literal notranslate"><span class="pre">frame_data[2]</span></code> with the
function <code class="docutils literal notranslate"><span class="pre">attribute_store_set_child_reported</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">attribute_store_set_child_reported</span></code> allows you to update an attribute
located under a node ID. Here we have the endpoint node ID so we can set
the value of any attribute right underneath.</p>
<p>Now we can repeat this process for all the available commands
(get/set/report) and set/get attribute based on your needs.</p>
</section>
<section id="testing-our-implementation">
<span id="id2"></span><h3>Testing our implementation<a class="headerlink" href="#testing-our-implementation" title="Permalink to this heading"></a></h3>
<p>You can test if the request are correctly sent and received by manually
making changes in the attribute store. To do so, you’ll need access to
the ZPC CLI. Start the zpc executable directly (and stop the uic-service
if running). Once its running press enter to see the <code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span></code> command
line. It supports autocompletion and the help command.</p>
<p>You can search for the node ID with the various log functions. The most
useful one is <code class="docutils literal notranslate"><span class="pre">attribute_store_log_search</span></code> that allows you to search
(case sensitive) for an attribute description.</p>
<p>Once you’ve got the node ID you can use functions such as
<code class="docutils literal notranslate"><span class="pre">attribute_store_set_desired</span> <span class="pre">nodeID,value</span></code> or
<code class="docutils literal notranslate"><span class="pre">attribute_store_undefine_reported</span> <span class="pre">nodeID</span></code> to trigger some changes.</p>
<p>You can also send raw Z-Wave frames with the <code class="docutils literal notranslate"><span class="pre">zwave_tx</span></code> commands.</p>
</section>
</section>
<section id="mapping-z-wave-to-dotdot-ucl-with-uam-file">
<h2>Mapping Z-Wave to Dotdot UCL with .uam file<a class="headerlink" href="#mapping-z-wave-to-dotdot-ucl-with-uam-file" title="Permalink to this heading"></a></h2>
<p>You should have some basic knowledge about clusters and UAM files.</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../doc/unify_specifications/Chapter02-ZCL-in-uic.html"><span class="doc">Cluster attributes</span></a></p></li>
<li><p><a class="reference internal" href="../../doc/how_to_write_uam_files.html"><span class="doc">.uam file documentation</span></a></p></li>
<li><p><a class="reference internal" href="how_to_write_uam_files_for_the_zpc.html"><span class="doc">Z-Wave specific .uam files documentation</span></a></p></li>
</ul>
<p>Now that our attribute store is correctly defined and sending the right
Z-Wave commands it’s time to map it to the UCL model. This allows our
attributes to be controlled by the MQTT broker (and by some extend the
dev UI).</p>
</section>
<section id="map-z-wave-attribute-to-clusters-attributes">
<h2>Map Z-Wave attribute to clusters attributes<a class="headerlink" href="#map-z-wave-attribute-to-clusters-attributes" title="Permalink to this heading"></a></h2>
<p>The clusters are represented by XML files located in
<code class="docutils literal notranslate"><span class="pre">components\uic_dotdot\dotdot-xml</span></code>. Our Sound Switch command class
need at least the following features :</p>
<ul class="simple">
<li><p>Play a tone</p></li>
<li><p>Configure volume</p></li>
<li><p>Configure tone ID</p></li>
</ul>
<p>The play tone is basically a switch (0: stop playing, 255: playing). It
can be represented by the <code class="docutils literal notranslate"><span class="pre">OnOff</span></code> cluster.</p>
<p>The volume and tone ID are numerical values. It can be represented by
the <code class="docutils literal notranslate"><span class="pre">Level</span></code> cluster that can control numerical values.</p>
<p>We’ll start by the simplest one, the <code class="docutils literal notranslate"><span class="pre">OnOff</span></code> cluster. If we take a
look at the OnOff cluster we can see the attribute it defines :</p>
<section id="on-off-cluster">
<span id="id3"></span><h3>On/Off cluster<a class="headerlink" href="#on-off-cluster" title="Permalink to this heading"></a></h3>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;zcl:cluster</span>
<span class="w"> </span><span class="na">xmlns:zcl=</span><span class="s">&quot;http://zigbee.org/zcl/clusters&quot;</span>
<span class="w"> </span><span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="w"> </span><span class="na">xmlns:type=</span><span class="s">&quot;http://zigbee.org/zcl/types&quot;</span>
<span class="w"> </span><span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span>
<span class="w"> </span><span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://zigbee.org/zcl/clusters cluster.xsd http://zigbee.org/zcl/types type.xsd&quot;</span>
<span class="w"> </span><span class="na">id=</span><span class="s">&quot;0006&quot;</span><span class="w"> </span><span class="na">revision=</span><span class="s">&quot;2&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;OnOff&quot;</span><span class="nt">&gt;</span>
<span class="cm">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;server&gt;</span>
<span class="w">    </span><span class="nt">&lt;attributes&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0000&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;OnOff&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;bool&quot;</span><span class="w"> </span><span class="na">max=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">required=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">reportRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">sceneRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">      </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">    </span><span class="nt">&lt;/attributes&gt;</span>
<span class="w">    </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">  </span><span class="nt">&lt;/server&gt;</span>
<span class="nt">&lt;/zcl:cluster&gt;</span>
</pre></div>
</div>
<p>Here, we are interested in the <code class="docutils literal notranslate"><span class="pre">OnOff</span></code> attribute with id <code class="docutils literal notranslate"><span class="pre">0000</span></code>.
It’s that ZCL attribute that is mapped to our
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span></code> Z-Wave attribute. An
other important information is the cluster ID in the <code class="docutils literal notranslate"><span class="pre">zcl:cluster</span></code>
attributes (<code class="docutils literal notranslate"><span class="pre">id=&quot;0006&quot;</span></code>).</p>
<p>In <code class="docutils literal notranslate"><span class="pre">applications/zpc/components/dotdot_mapper/rules</span></code> we can create our
uam file. It must be named by the following naming convention :
<code class="docutils literal notranslate"><span class="pre">{CLUSTER_NAME}_to_{COMMAND_CLASS_NAME}CC</span></code> where <code class="docutils literal notranslate"><span class="pre">{CLUSTER_NAME}</span></code> is
the ZCL cluster name and <code class="docutils literal notranslate"><span class="pre">{COMMAND_CLASS_NAME}</span></code> is your Z-Wave command
class name (without spaces). We name our file
<code class="docutils literal notranslate"><span class="pre">OnOff_to_SoundSwitchCC.uam</span></code>.</p>
<p>The first thing we’ll do is to define where to find our Z-Wave
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span></code> attribute. Remember
in the beginning <a class="reference internal" href="#attribute-id-in-the-attribute-store"><span class="std std-ref">when we defined some ID for our Z-Wave attributes</span></a> ?
This is where we’ll use it. Our command class sound switch have the ID <code class="docutils literal notranslate"><span class="pre">0x79</span></code>
and <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONE_PLAY</span></code> <code class="docutils literal notranslate"><span class="pre">0x08</span></code>. We can
access to this attribute by doing :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zwSOUND_SWITCH_TONE_PLAY</span> <span class="no">0x7908</span>
</pre></div>
</div>
<p>It works the same way for the OnOff cluster attributes. We take the
cluster ID (<code class="docutils literal notranslate"><span class="pre">0006</span></code>) followed by the attribute ID (<code class="docutils literal notranslate"><span class="pre">0000</span></code>) :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zbON_OFF</span> <span class="no">0x00060000</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The naming convention is to prefix Z-Wave attribute with
<code class="docutils literal notranslate"><span class="pre">zw</span></code> and ZCL attributes with <code class="docutils literal notranslate"><span class="pre">zb</span></code>.</p>
</div>
<p>We usually use the priority 25 for this kind of rules to have higher
priority over generic switches.</p>
<p>We need to prevent <code class="docutils literal notranslate"><span class="pre">chain_reaction</span></code> because we map the Z-Wave to zcl
and vice versa.</p>
<ul class="simple">
<li><p><em>Z-Wave to zcl</em> : Used when attribute store is updated (e.g Z-Wave
report command)</p></li>
<li><p><em>zcl to Z-Wave</em> : Used when zcl model is updated (e.g with commands)</p></li>
</ul>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zwave_no_sound_switch</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_PLAY</span> <span class="ow">==</span> <span class="no">0</span>)

<span class="nb">scope</span> <span class="no">25</span> <span class="no">chain_reaction</span>(<span class="no">0</span>) {
  <span class="c c-Singleline">// Linking attributes zwave -&gt; zigbee (note : 0 is stop playing)</span>
  <span class="nv">r&#39;zbON_OFF</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">r&#39;zwSOUND_SWITCH_TONE_PLAY</span> !<span class="o">=</span> <span class="no">0</span>) <span class="no">1</span> <span class="no">0</span>
  <span class="nv">d&#39;zbON_OFF</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">d&#39;zwSOUND_SWITCH_TONE_PLAY</span> !<span class="o">=</span> <span class="no">0</span>) <span class="no">1</span> <span class="no">0</span>

  <span class="c c-Singleline">// Linking attributes zigbee -&gt; zwave</span>
  <span class="nv">d&#39;zwSOUND_SWITCH_TONE_PLAY</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">d&#39;zbON_OFF</span> !<span class="o">=</span> <span class="no">0</span>) <span class="no">255</span> <span class="no">0</span>

  <span class="nv">r&#39;zwSOUND_SWITCH_TONE_PLAY</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nb">if</span> (<span class="nv">r&#39;zbON_OFF</span> !<span class="o">=</span> <span class="no">0</span>) <span class="no">255</span> <span class="no">0</span>
}
</pre></div>
</div>
<p>This way we ensure that both attribute are linked no matter if it’s
changed in the ZCL world or Z-Wave world. <code class="docutils literal notranslate"><span class="pre">chain_reaction(0)</span></code> prevent
the mapper to go in a infinite loop.</p>
<section id="uam-guard">
<span id="id4"></span><h4>UAM Guard<a class="headerlink" href="#uam-guard" title="Permalink to this heading"></a></h4>
<p>In our previous UAM example we have defined an function that checks if
the Sound Switch Command Class is active for the current endpoint :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zwave_no_sound_switch</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_PLAY</span> <span class="ow">==</span> <span class="no">0</span>)
</pre></div>
</div>
<p>Here we check the existence of <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_PLAY</span></code> to see if
the endpoint is supporting Sound Switch.</p>
<p>We need to make sure that if we don’t have any sound switch active that
:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_PLAY</span></code> should not exist and not be mapped to
the <code class="docutils literal notranslate"><span class="pre">zbON_OFF</span></code> value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zbON_OFF</span></code> doesn’t take the value of <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_PLAY</span></code>.
This prevents conflict with other Z-Wave CC (like Binary Switch that
also maps to <code class="docutils literal notranslate"><span class="pre">zbON_OFF</span></code>).</p></li>
</ul>
<p>Make sure that your UAM file contains this guard to prevent
interferences with other command classes implementation.</p>
</section>
</section>
<section id="level-cluster">
<h3>Level cluster<a class="headerlink" href="#level-cluster" title="Permalink to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">OnOff</span></code> cluster was very straight forward, but the <code class="docutils literal notranslate"><span class="pre">Level</span></code>
requires some arbitrary choices. We need to map 2 values :</p>
<ul class="simple">
<li><p>The current volume</p></li>
<li><p>The current tone ID</p></li>
</ul>
<p>Let’s look at the <code class="docutils literal notranslate"><span class="pre">Level</span></code> cluster definition :</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;zcl:cluster</span>
<span class="w">  </span><span class="na">xmlns:zcl=</span><span class="s">&quot;http://zigbee.org/zcl/clusters&quot;</span>
<span class="w">  </span><span class="na">xmlns:xsi=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
<span class="w">  </span><span class="na">xmlns:type=</span><span class="s">&quot;http://zigbee.org/zcl/types&quot;</span>
<span class="w">  </span><span class="na">xmlns:xi=</span><span class="s">&quot;http://www.w3.org/2001/XInclude&quot;</span>
<span class="w">  </span><span class="na">xsi:schemaLocation=</span><span class="s">&quot;http://zigbee.org/zcl/clusters cluster.xsd http://zigbee.org/zcl/types type.xsd&quot;</span>
<span class="w">  </span><span class="na">id=</span><span class="s">&quot;0008&quot;</span><span class="w"> </span><span class="na">revision=</span><span class="s">&quot;2&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Level&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;classification</span><span class="w"> </span><span class="na">role=</span><span class="s">&quot;application&quot;</span><span class="w"> </span><span class="na">picsCode=</span><span class="s">&quot;LVL&quot;</span><span class="w"> </span><span class="na">primaryTransaction=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">  </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">  </span><span class="nt">&lt;server&gt;</span>
<span class="w">    </span><span class="nt">&lt;attributes&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0000&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;CurrentLevel&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint8&quot;</span><span class="w"> </span><span class="na">reportRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">sceneRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;255&quot;</span><span class="w"> </span><span class="na">required=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:minInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MinLevel&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:maxInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MaxLevel&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0002&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MinLevel&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint8&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:maxInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MaxLevel&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0003&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MaxLevel&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint8&quot;</span><span class="w"> </span><span class="na">max=</span><span class="s">&quot;255&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;255&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:minInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MinLevel&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>

<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0004&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;CurrentFrequency&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint16&quot;</span><span class="w"> </span><span class="na">reportRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">sceneRequired=</span><span class="s">&quot;true&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:minInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MinFrequency&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:maxInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MaxFrequency&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0005&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MinFrequency&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint16&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:maxInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MaxFrequency&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="nt">&lt;attribute</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;0006&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MaxFrequency&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;uint16&quot;</span><span class="w"> </span><span class="na">max=</span><span class="s">&quot;65535&quot;</span><span class="w"> </span><span class="na">default=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
<span class="w">        </span><span class="nt">&lt;restriction&gt;</span>
<span class="w">          </span><span class="nt">&lt;type:minInclusiveRef</span><span class="w"> </span><span class="na">ref=</span><span class="s">&quot;MinFrequency&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">        </span><span class="nt">&lt;/restriction&gt;</span>
<span class="w">      </span><span class="nt">&lt;/attribute&gt;</span>
<span class="w">      </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">    </span><span class="nt">&lt;/attributes&gt;</span>
<span class="w">    </span><span class="cm">&lt;!-- ... --&gt;</span>
<span class="w">  </span><span class="nt">&lt;/server&gt;</span>
<span class="nt">&lt;/zcl:cluster&gt;</span>
</pre></div>
</div>
<p>We see that we have access to 2 int attributes : <code class="docutils literal notranslate"><span class="pre">CurrentLevel</span></code> and
<code class="docutils literal notranslate"><span class="pre">CurrentFrequency</span></code>. We can decide to map the current volume to
<code class="docutils literal notranslate"><span class="pre">CurrentLevel</span></code> and current tone ID to <code class="docutils literal notranslate"><span class="pre">CurrentFrequency</span></code> (even if
its make little sense). We’ll see how to implement our own cluster if we
need more accuracy <span class="xref std std-doc">here</span>.</p>
<p>Both ZCL attributes have a min and a max values, so we need to map those
as well.</p>
<p>First we’ll create our file <code class="docutils literal notranslate"><span class="pre">Level_to_SoundSwitchCC.uam</span></code> in
<code class="docutils literal notranslate"><span class="pre">applications/zpc/components/dotdot_mapper/rules</span></code>.</p>
<p>Let’s define our Z-Wave attribute definitions :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zwSOUND_SWITCH_CONFIGURED_VOLUME</span> <span class="no">0x7902</span>
<span class="nb">def</span> <span class="no">zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span> <span class="no">0x7903</span>
<span class="nb">def</span> <span class="no">zwSOUND_SWITCH_TONE_NUMBER</span> <span class="no">0x7904</span>
</pre></div>
</div>
<p>We bind <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_NUMBER</span></code> the to the <code class="docutils literal notranslate"><span class="pre">MaxFrequency</span></code>
attribute so that our <code class="docutils literal notranslate"><span class="pre">CurrentFrequency</span></code> doesn’t overflow. Since
<code class="docutils literal notranslate"><span class="pre">CurrentFrequency</span></code> here represent our tone ID it must be between 1 and
<code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_NUMBER</span></code>.</p>
<p>And our zcl level attributes :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zbLEVEL_CLUSTER_LEVEL</span>   <span class="no">0x00080000</span>
<span class="nb">def</span> <span class="no">zbLEVEL_CLUSTER_MIN_LEVEL</span> <span class="no">0x00080002</span>
<span class="nb">def</span> <span class="no">zbLEVEL_CLUSTER_MAX_LEVEL</span> <span class="no">0x00080003</span>
<span class="nb">def</span> <span class="no">zbLEVEL_CLUSTER_FREQ</span> <span class="no">0x00080004</span>
<span class="nb">def</span> <span class="no">zbLEVEL_CLUSTER_FREQ_MIN</span> <span class="no">0x00080005</span>
<span class="nb">def</span> <span class="no">zbLEVEL_CLUSTER_FREQ_MAX</span> <span class="no">0x00080006</span>
<span class="nb">def</span> <span class="no">zbLEVEL_CLUSTER_TRANSITION_TIME</span> <span class="no">0x00080010</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">zbLEVEL_CLUSTER_TRANSITION_TIME</span></code> is here to enable the Move
command. We define it to make sure we can move our value the way we want
to.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To understand how we get the various ID see the <a class="reference internal" href="#on-off-cluster"><span class="std std-ref">OnOff cluster section</span></a></p>
</div>
<p>We need some constants for the min/max volume also since it is not
defined on our command class :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">min_level</span> <span class="no">0</span>
<span class="nb">def</span> <span class="no">max_level</span> <span class="no">100</span>
</pre></div>
</div>
<p>First we’ll map une CurrentLevel and CurrentFrequency attributes with
their counterpart :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zwave_no_sound_switch</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_PLAY</span> <span class="ow">==</span> <span class="no">0</span>)

<span class="nb">scope</span> <span class="no">25</span>  <span class="no">chain_reaction</span>(<span class="no">0</span>) {
  <span class="c c-Singleline">// Map current level to configured volume</span>
  <span class="c c-Singleline">// zwave -&gt; ucl</span>
  <span class="nv">r&#39;zbLEVEL_CLUSTER_LEVEL</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">r&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span>
  <span class="nv">d&#39;zbLEVEL_CLUSTER_LEVEL</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">d&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span>
  <span class="c c-Singleline">// ucl -&gt; zwave</span>
  <span class="nv">d&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">d&#39;zbLEVEL_CLUSTER_LEVEL</span>
  <span class="nv">r&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">r&#39;zbLEVEL_CLUSTER_LEVEL</span>

  <span class="c c-Singleline">// Map frequency to current tone identifier</span>
  <span class="c c-Singleline">// zwave -&gt; ucl</span>
  <span class="nv">r&#39;zbLEVEL_CLUSTER_FREQ</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">r&#39;zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span>
  <span class="nv">d&#39;zbLEVEL_CLUSTER_FREQ</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">d&#39;zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span>
  <span class="c c-Singleline">// ucl -&gt; zwave</span>
  <span class="nv">d&#39;zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">d&#39;zbLEVEL_CLUSTER_FREQ</span>
  <span class="nv">r&#39;zwSOUND_SWITCH_TONE_INFO_IDENTIFIER</span> <span class="o">=</span>
    <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
    <span class="nv">r&#39;zbLEVEL_CLUSTER_FREQ</span>
}
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This process is explained in <a class="reference internal" href="#on-off-cluster"><span class="std std-ref">OnOff cluster
section</span></a> and the <code class="docutils literal notranslate"><span class="pre">zwave_no_sound_switch</span></code> in
<a class="reference internal" href="#uam-guard"><span class="std std-ref">UAM Guard section</span></a></p>
</div>
<p>To bind the min and max values we add those rules :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="c c-Singleline">// Min and max volume</span>
<span class="nv">r&#39;zbLEVEL_CLUSTER_MIN_LEVEL</span> <span class="o">=</span>
  <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
  <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span>) <span class="no">min_level</span> <span class="no">undefined</span>
<span class="nv">r&#39;zbLEVEL_CLUSTER_MAX_LEVEL</span> <span class="o">=</span>
  <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
  <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_CONFIGURED_VOLUME</span>) <span class="no">max_level</span> <span class="no">undefined</span>
</pre></div>
</div>
<p>We can’t bind value to raw constants so we need to add an condition to
it. We choose to define it only if <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_CONFIGURED_VOLUME</span></code>
exists since if it doesn’t the min/max value doesn’t make sense.</p>
<p>Same applies for <code class="docutils literal notranslate"><span class="pre">MinFrequency</span></code> and <code class="docutils literal notranslate"><span class="pre">MaxFrequency</span></code> but instead of
constants we use our <code class="docutils literal notranslate"><span class="pre">zwSOUND_SWITCH_TONE_NUMBER</span></code> attribute :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nv">r&#39;zbLEVEL_CLUSTER_FREQ_MIN</span> <span class="o">=</span>
   <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
   <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_NUMBER</span>) <span class="no">1</span> <span class="no">undefined</span>
 <span class="nv">r&#39;zbLEVEL_CLUSTER_FREQ_MAX</span> <span class="o">=</span>
   <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
   <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_NUMBER</span>) <span class="nv">r&#39;zwSOUND_SWITCH_TONE_NUMBER</span> <span class="no">undefined</span>
</pre></div>
</div>
<p>The last attribute we need to define is
<code class="docutils literal notranslate"><span class="pre">zbLEVEL_CLUSTER_TRANSITION_TIME</span></code> to make <code class="docutils literal notranslate"><span class="pre">Level</span></code> commands work. All
we need to do is set a value. In our case we choose 0 because we don’t
want a transition time when updating our levels.</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="c c-Singleline">// Required to enable move command</span>
<span class="nv">d&#39;zbLEVEL_CLUSTER_TRANSITION_TIME</span> <span class="o">=</span>
  <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
  <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_NUMBER</span>) <span class="no">0</span> <span class="no">undefined</span>
<span class="nv">r&#39;zbLEVEL_CLUSTER_TRANSITION_TIME</span> <span class="o">=</span>
  <span class="nb">if</span> (<span class="no">zwave_no_sound_switch</span>) <span class="no">undefined</span>
  <span class="nb">if</span> (<span class="nv">e&#39;zwSOUND_SWITCH_TONE_NUMBER</span>) <span class="no">0</span> <span class="no">undefined</span>
</pre></div>
</div>
<p>Now with those files we should be able to control our device from the
MQTT broker and the dev UI since it monitors the ZCL attributes.</p>
</section>
</section>
<section id="quirks">
<h2>Quirks<a class="headerlink" href="#quirks" title="Permalink to this heading"></a></h2>
<p>Sometimes, devices are not acting like they should. The Aeotec Doorbell
6 for example define 9 different endpoints. Each endpoint can have its
own configuration (tone ID, volume) and can play a tune. However, the
first endpoint is behaving differently from the others.</p>
<p>It acts as a default endpoint that copy the configuration of the second
one (ep1). That means if you send a play command to the first endpoint,
the second one is also marked as “is playing” and both use the same
configuration (tone ID, volume).</p>
<p>When we tell the first endpoint (ep0) to play, the second one (ep1) is
also marked as “is playing”, but when the tone finishes only the ep1
receive a report telling the sound is over leading the ep0 in a
incorrect state (marked as playing but in reality it’s not).</p>
<p>To address this issue we can use something we call Quirks in UAM. They
allow us to execute rules on a specific device. The naming convention is
<code class="docutils literal notranslate"><span class="pre">Quirks_{device_name}.uam</span></code> where <code class="docutils literal notranslate"><span class="pre">{device_name}</span></code> is your device
name. In our case we can create <code class="docutils literal notranslate"><span class="pre">Quirks_aeotec_doorbell.uam</span></code>.</p>
<p>A device can be identified with 3 parameters : manufacturer ID, product
type and product ID. We can have access to it in UAM with the following
ID :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="c c-Singleline">// Special maps to help controlling the Aeotec doorbell</span>
<span class="nb">def</span> <span class="no">zwMANUFACTURER_ID</span>           <span class="no">0x00007202</span>
<span class="nb">def</span> <span class="no">zwPRODUCT_TYPE</span>              <span class="no">0x00007203</span>
<span class="nb">def</span> <span class="no">zwPRODUCT_ID</span>                <span class="no">0x00007204</span>
</pre></div>
</div>
<p>We the need a reference to the <code class="docutils literal notranslate"><span class="pre">SOUND_SWITCH_TONE_PLAY</span></code> attribute :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">zwSOUND_SWITCH_TONE_PLAY</span> <span class="no">0x7908</span>
</pre></div>
</div>
<p>We also need to have access to the endpoint list :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">ep</span> <span class="no">4</span>
</pre></div>
</div>
<p>This allow us to reference each endpoint by doing <code class="docutils literal notranslate"><span class="pre">ep[0]</span></code> where <code class="docutils literal notranslate"><span class="pre">0</span></code>
is the endpoint ID. This notation will be explained soon.</p>
<p>The last definition we need is a condition that returns true if we are
controlling our specific device. We use the manufacturer ID, product
type and product ID to identify our device. You can find those either in
the attribute tree (<code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Manufacturer</span></code> and
<code class="docutils literal notranslate"><span class="pre">ZPC&gt;</span> <span class="pre">attribute_store_log_search</span> <span class="pre">Product</span></code>) or directly in the vendor
manual.</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">def</span> <span class="no">aeotec_doorbell</span> ((<span class="nv">r&#39;ep[0].zwMANUFACTURER_ID</span> <span class="ow">==</span> <span class="no">881</span>) <span class="ow">&amp;</span> (<span class="nv">r&#39;ep[0].zwPRODUCT_TYPE</span> <span class="ow">==</span> <span class="no">3</span>) <span class="ow">&amp;</span> (<span class="nv">r&#39;ep[0].zwPRODUCT_ID</span> <span class="ow">==</span> <span class="no">162</span>))
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We have to write the endpoint (<code class="docutils literal notranslate"><span class="pre">ep[0]</span></code>) before acceding the
device identifiers or it will not work. This is explained bellow.</p>
</div>
<p>The Quirk need to run as a high priority rule since they are device
specific. Most of the Quirks runs as a priority of 500 or higher. Also
in our case we need to have access to the endpoint list. Defining <code class="docutils literal notranslate"><span class="pre">ep</span></code>
is not all we need to do : we also need <code class="docutils literal notranslate"><span class="pre">common_parent_type(3)</span></code> to our
rules :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">scope</span> <span class="no">500</span> <span class="no">common_parent_type</span>(<span class="no">3</span>) {
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">common_parent_type(3)</span></code> changes the current scope configuration
for this mapping. This allows us to have access to each endpoint
(<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">ep</span> <span class="pre">4</span></code>). The numbers (<code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">4</span></code>) are references to the
attributes’ ID. In
<code class="docutils literal notranslate"><span class="pre">applications\zpc\components\zpc_attribute_store\include\attribute_store_defined_attribute_types.h</span></code>
we can find :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">///&lt; This represents a Node ID. zwave_node_id_t type.</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_NODE_ID</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0003</span><span class="p">)</span>
<span class="c1">///&lt; This represents an endpoint. zwave_endpoint_id_t type.</span>
<span class="n">DEFINE_ATTRIBUTE</span><span class="p">(</span><span class="n">ATTRIBUTE_ENDPOINT_ID</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0004</span><span class="p">)</span>
</pre></div>
</div>
<p>If we look at our current attribute store we may see something like that
:</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>(1) Root node .................................................................     &lt;&gt; (&lt;&gt;)
    │───(2) HomeID ............................................................ [58,27,e5,fc] (&lt;&gt;)
    │   │───(3) NodeID ........................................................      1 (&lt;&gt;)
    │   │   │───(4) Endpoint ID ...............................................      0 (&lt;&gt;)
    │   │───(8) NodeID ........................................................      3 (&lt;&gt;)
    │   │   │───(9) Endpoint ID ...............................................      0 (&lt;&gt;)
    │   │   │───(153) Endpoint ID .............................................      1 (&lt;&gt;)
    │   │   │───(157) Endpoint ID .............................................      2 (&lt;&gt;)
    │   │   │───(161) Endpoint ID .............................................      3 (&lt;&gt;)
    │   │   │───(165) Endpoint ID .............................................      4 (&lt;&gt;)
    │   │   │───(169) Endpoint ID .............................................      5 (&lt;&gt;)
    │   │   │───(173) Endpoint ID .............................................      6 (&lt;&gt;)
    │   │   │───(177) Endpoint ID .............................................      7 (&lt;&gt;)
    │   │   │───(181) Endpoint ID .............................................      8 (&lt;&gt;)
</pre></div>
</div>
<p>If we position ourselves relative to our Node ID we can access each
endpoint individually.</p>
<p><code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_NODE_ID</span></code> is defined at <code class="docutils literal notranslate"><span class="pre">0x0003</span></code> and
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code> at <code class="docutils literal notranslate"><span class="pre">0x0004</span></code>. That’s why we defined <code class="docutils literal notranslate"><span class="pre">ep</span></code> to
<code class="docutils literal notranslate"><span class="pre">4</span></code> earlier. Now we tell that for this mapping our parent is the
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_NODE_ID</span></code> with <code class="docutils literal notranslate"><span class="pre">common_parent_type(3)</span></code>. This way <code class="docutils literal notranslate"><span class="pre">ep[0]</span></code>
reference the tree under the first endpoint, <code class="docutils literal notranslate"><span class="pre">ep[1]</span></code> the tree under
the second endpoint, etc.</p>
<p>This is why we needed to add <code class="docutils literal notranslate"><span class="pre">ep[0]</span></code> before <code class="docutils literal notranslate"><span class="pre">zwMANUFACTURER_ID</span></code> and
the other attributes in <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">aeotec_doorbell</span></code>. Since its evaluated in
the <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_NODE_ID</span></code> context the only attribute directly available
is the <code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_ENDPOINT_ID</span></code>. You can find more information about
this in <a class="reference internal" href="../../doc/how_to_write_uam_files.html"><span class="doc">How to write UAM files</span></a></p>
<p>So we need to map the second endpoint (<code class="docutils literal notranslate"><span class="pre">ep[1]</span></code>) tone play value to
match the first one (<code class="docutils literal notranslate"><span class="pre">ep[0]</span></code>) but ONLY when the device is the Aoetec
doorbell :</p>
<div class="highlight-uam notranslate"><div class="highlight"><pre><span></span><span class="nb">scope</span> <span class="no">500</span> <span class="no">common_parent_type</span>(<span class="no">3</span>) {
  <span class="nv">r&#39;ep[0].zwSOUND_SWITCH_TONE_PLAY</span> <span class="o">=</span> <span class="nb">if</span> <span class="no">aeotec_doorbell</span> <span class="nv">r&#39;ep[1].zwSOUND_SWITCH_TONE_PLAY</span> <span class="no">undefined</span>
}
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">aeotec_doorbell</span></code> report <code class="docutils literal notranslate"><span class="pre">false</span></code> we set the reported value to
<code class="docutils literal notranslate"><span class="pre">undefined</span></code> to let other rules take care of it. Otherwise we map the
value to the value reported by the second endpoint.</p>
</section>
<section id="unit-testing">
<h2>Unit Testing<a class="headerlink" href="#unit-testing" title="Permalink to this heading"></a></h2>
<p>An approach that can be used to implement the test class is to try and
think based on the command class specification and the code of the
command class the good and bad scenarios that could happen. A suggestion
is to try and create a method for each bad scenario, based on the
implementation of the command class could be necessary in some occasions
to create some nodes to test if any change happens to others.</p>
<p>The test files are located under
<code class="docutils literal notranslate"><span class="pre">applications/zpc/components/zwave_command_classes/test</span></code>. The naming
convention is <code class="docutils literal notranslate"><span class="pre">zwave_command_class_{COMMAND_CLASS}_test.c</span></code> so in our
case the file is named <code class="docutils literal notranslate"><span class="pre">zwave_command_class_sound_switch_test.c</span></code>.</p>
<p>Test are enabled by default in CMake. The CMake variable
<code class="docutils literal notranslate"><span class="pre">BUILD_TESTING</span></code> is controlling the test suite. Make sure it is set to
<code class="docutils literal notranslate"><span class="pre">ON</span></code> (either via the pseudo-gui <code class="docutils literal notranslate"><span class="pre">ccmake</span></code> or by passing the
<code class="docutils literal notranslate"><span class="pre">-DBUILD_TESTING=ON</span></code> to cmake directly).</p>
<p>Once the compilation is done, you can run all the tests with <code class="docutils literal notranslate"><span class="pre">ctest</span></code>
in your build directory. You can also run a specific test with the
command : <code class="docutils literal notranslate"><span class="pre">ctest</span> <span class="pre">-R</span> <span class="pre">name_of_your_test</span></code>. The name of your test is
defined with the <code class="docutils literal notranslate"><span class="pre">NAME</span></code> argument of the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> in the test
folder (see next section for details).</p>
<p>If you need for details about your test result, pass the <code class="docutils literal notranslate"><span class="pre">--verbose</span></code>
option.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Try to use the <code class="docutils literal notranslate"><span class="pre">MESSAGE</span></code> variant as much as possible in your tests
(e.g. <code class="docutils literal notranslate"><span class="pre">TEST_ASSERT_EQUAL_MESSAGE</span></code>) to provide a meaningful message
when a test fails.</p>
<p>This will help debugging the test and understand what went wrong.</p>
</div>
<section id="add-test-file-to-cmake">
<h3>Add test file to CMake<a class="headerlink" href="#add-test-file-to-cmake" title="Permalink to this heading"></a></h3>
<p>After creating the file we need to add it to the CMake build system. To
do so open the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> located in the test folder and add :</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Sound switch unit test</span>
<span class="nb">target_add_unittest</span><span class="p">(</span><span class="s">zwave_command_classes</span>

<span class="s">NAME</span><span class="w"> </span><span class="s">zwave_command_class_sound_switch_test</span>
<span class="s">SOURCES</span><span class="w"> </span><span class="s">zwave_command_class_sound_switch_test.c</span>

<span class="s">DEPENDS</span>
<span class="w">  </span><span class="s">zpc_attribute_store_test_helper</span>
<span class="w">  </span><span class="s">zwave_controller</span>
<span class="w">  </span><span class="s">zwave_command_handler_mock</span>
<span class="w">  </span><span class="s">uic_attribute_resolver_mock</span>
<span class="w">  </span><span class="s">zpc_attribute_resolver_mock</span>
<span class="w">  </span><span class="s">uic_dotdot_mqtt_mock</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NAME</span></code> : Same name as the SOURCE argument but without the extension
(used if you want to run this specific test with
<code class="docutils literal notranslate"><span class="pre">ctest</span> <span class="pre">-R</span> <span class="pre">name_of_your_test</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SOURCES</span></code> : Our test file name with the extension</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DEPENDS</span></code> : Dependencies of our test. You may add some based on
your needs. More is available you can look at other test definitions
to see them.</p></li>
</ul>
</section>
<section id="base-test-skeleton">
<h3>Base test skeleton<a class="headerlink" href="#base-test-skeleton" title="Permalink to this heading"></a></h3>
<p>Once it is added to our build system, we define the test skeleton like
this :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_class_sound_switch.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_classes_utils.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;unity.h&quot;</span>

<span class="c1">// Generic includes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>

<span class="c1">// Includes from other components</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;datastore.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_helper.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_fixt.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zpc_attribute_store_type_registration.h&quot;</span>

<span class="c1">// Interface includes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_store_defined_attribute_types.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ZW_classcmd.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_utils.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_controller_types.h&quot;</span>

<span class="c1">// Test helpers</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zpc_attribute_store_test_helper.h&quot;</span>

<span class="c1">// Mock includes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;attribute_resolver_mock.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zpc_attribute_resolver_mock.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;zwave_command_handler_mock.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;dotdot_mqtt_mock.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;dotdot_mqtt_generated_commands_mock.h&quot;</span>

<span class="c1">/// Setup the test suite (called once before all test_xxx functions are called)</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">suiteSetUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">datastore_init</span><span class="p">(</span><span class="s">&quot;:memory:&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">attribute_store_init</span><span class="p">();</span>
<span class="w">  </span><span class="n">zpc_attribute_store_register_known_attribute_types</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// Teardown the test suite (called once after all test_xxx functions are called)</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">suiteTearDown</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num_failures</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">attribute_store_teardown</span><span class="p">();</span>
<span class="w">  </span><span class="n">datastore_teardown</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">num_failures</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Called before each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">zpc_attribute_store_test_helper_create_network</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// Called after each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">tearDown</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>You can find the different function that is called before/after each
test/test suite.</p>
<p>We’ll add to the <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> function the entrypoint of our class :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Called before each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">zpc_attribute_store_test_helper_create_network</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Call init</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="n">SL_STATUS_OK</span><span class="p">,</span><span class="w"> </span><span class="n">zwave_command_class_sound_switch_init</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unless your specified your attribute creation in this function, your
attribute tree is <strong>NOT</strong> available for the test cases. If your
attribute creation is bound to the version update, you can set this
attribute in the setUp() phase if really needed :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">version_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_add_node</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_VERSION</span><span class="p">,</span>
<span class="w">    </span><span class="n">endpoint_id_node</span><span class="p">);</span>

<span class="w">  </span><span class="n">zwave_cc_version_t</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">attribute_store_set_reported</span><span class="p">(</span><span class="n">version_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">version</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="test-report-z-wave-function">
<h3>Test report Z-Wave function<a class="headerlink" href="#test-report-z-wave-function" title="Permalink to this heading"></a></h3>
<p>We’ll add an handler stub that contains our sound switch handler
definition (version, security, control handler,…). The handler stub
function looks like this :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Private variables</span>
<span class="k">static</span><span class="w"> </span><span class="n">zwave_command_handler_t</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="c1">// Stub for registering command classes</span>
<span class="k">static</span><span class="w"> </span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">zwave_command_handler_register_handler_stub</span><span class="p">(</span>
<span class="w">  </span><span class="n">zwave_command_handler_t</span><span class="w"> </span><span class="n">new_command_class_handler</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cmock_num_calls</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_command_class_handler</span><span class="p">;</span>

<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="n">ZWAVE_CONTROLLER_ENCAPSULATION_NONE</span><span class="p">,</span>
<span class="w">                    </span><span class="n">handler</span><span class="p">.</span><span class="n">minimal_scheme</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">command_class</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_MESSAGE</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p">.</span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Mismatch of supported version&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_NULL</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="n">support_handler</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_FALSE</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="n">manual_security_validation</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
</pre></div>
</div>
<p>We save our handler into a global static variable so we can use it later
in our test functions. All our test functions must start with the
<code class="docutils literal notranslate"><span class="pre">test_</span></code> prefix. If we want to test our configuration report in the
best case scenario, we can call this function
<code class="docutils literal notranslate"><span class="pre">test_sound_switch_configuration_report_happy_case()</span></code>. Or if we want
to test the volume doesn’t go above 100, we can name it
<code class="docutils literal notranslate"><span class="pre">test_sound_switch_configuration_report_volume_over_100()</span></code>.</p>
<p>Then, we add the stub definition in our <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> function :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Called before each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>

<span class="w">  </span><span class="c1">// Unset previous definition of handler</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handler</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">zwave_command_handler_t</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Handler registration</span>
<span class="w">  </span><span class="n">zwave_command_handler_register_handler_Stub</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">zwave_command_handler_register_handler_stub</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s good practice to init the handler to its default value before each
test. Now we can write a simple test for the configuration report :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_sound_switch_configuration_report_volume_over_100</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">zwave_controller_connection_info_t</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">remote</span><span class="p">.</span><span class="n">node_id</span><span class="w">                     </span><span class="o">=</span><span class="w"> </span><span class="n">node_id</span><span class="p">;</span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">remote</span><span class="p">.</span><span class="n">endpoint_id</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="n">endpoint_id</span><span class="p">;</span>
<span class="w">  </span><span class="n">info</span><span class="p">.</span><span class="n">local</span><span class="p">.</span><span class="n">is_multicast</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">  </span><span class="n">TEST_ASSERT_NOT_NULL_MESSAGE</span><span class="p">(</span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="p">,</span>
<span class="w">                              </span><span class="s">&quot;Control handler should have been registered&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_MESSAGE</span><span class="p">(</span><span class="n">SL_STATUS_FAIL</span><span class="p">,</span>
<span class="w">                    </span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span>
<span class="w">                    </span><span class="s">&quot;Report should have not worked on a empty frame&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">frame</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">,</span>
<span class="w">                           </span><span class="n">SOUND_SWITCH_CONFIGURATION_REPORT</span><span class="p">,</span>
<span class="w">                           </span><span class="mi">101</span><span class="p">,</span>
<span class="w">                           </span><span class="mh">0x55</span><span class="p">};</span>

<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_MESSAGE</span><span class="p">(</span><span class="n">SL_STATUS_OK</span><span class="p">,</span>
<span class="w">                    </span><span class="n">handler</span><span class="p">.</span><span class="n">control_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">frame</span><span class="p">)),</span>
<span class="w">                    </span><span class="s">&quot;Report should have worked with a valid frame&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">volume_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_node_child_by_type</span><span class="p">(</span>
<span class="w">    </span><span class="n">endpoint_id_node</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w">    </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_MESSAGE</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="n">attribute_store_get_reported_number</span><span class="p">(</span><span class="n">volume_node</span><span class="p">),</span>
<span class="w">                            </span><span class="s">&quot;Volume should not go above 100&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">tone_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_node_child_by_type</span><span class="p">(</span>
<span class="w">    </span><span class="n">endpoint_id_node</span><span class="p">,</span>
<span class="w">    </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span>
<span class="w">    </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_MESSAGE</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span><span class="w"> </span><span class="n">attribute_store_get_reported_number</span><span class="p">(</span><span class="n">tone_node</span><span class="p">),</span>
<span class="w">                            </span><span class="s">&quot;Tone value mismatch&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can send to our control handler a Z-Wave report frame of
configuration with <code class="docutils literal notranslate"><span class="pre">handler.control_handler()</span></code> and checks if the
attributes are correctly updated in the attribute store. This test
ensure that the sound level never goes over 100 even if reported so.</p>
</section>
<section id="test-get-set-z-wave-function">
<h3>Test get/set Z-Wave function<a class="headerlink" href="#test-get-set-z-wave-function" title="Permalink to this heading"></a></h3>
<p>We’ll had an handler stub that contains our sound switch get and set
callbacks. We defined our get and set function for
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span></code> and
<code class="docutils literal notranslate"><span class="pre">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span></code> like this :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">attribute_resolver_register_rule</span><span class="p">(</span>
<span class="w"> </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span>
<span class="w"> </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_set</span><span class="p">,</span>
<span class="w"> </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_configuration_get</span><span class="p">);</span>

<span class="n">attribute_resolver_register_rule</span><span class="p">(</span>
<span class="w"> </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">,</span>
<span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w"> </span><span class="o">&amp;</span><span class="n">zwave_command_class_sound_switch_tones_number_get</span><span class="p">);</span>
</pre></div>
</div>
<p>So we can access them like this in our test file :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">configuration_get</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">configuration_set</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">tone_number_get</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="c1">// Buffer for frame</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">received_frame</span><span class="p">[</span><span class="mi">255</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">received_frame_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Stub functions</span>
<span class="k">static</span><span class="w"> </span><span class="n">sl_status_t</span>
<span class="w">  </span><span class="nf">attribute_resolver_register_rule_stub</span><span class="p">(</span><span class="n">attribute_store_type_t</span><span class="w"> </span><span class="n">node_type</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">set_func</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">attribute_resolver_function_t</span><span class="w"> </span><span class="n">get_func</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">int</span><span class="w"> </span><span class="n">cmock_num_calls</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">set_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">get_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">configuration_get</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_func</span><span class="p">;</span>
<span class="w">    </span><span class="n">configuration_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">set_func</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_TONES_NUMBER</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TEST_ASSERT_NULL</span><span class="p">(</span><span class="n">set_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">get_func</span><span class="p">);</span>
<span class="w">    </span><span class="n">tone_number_get</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_func</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that we might don’t have a set and get function for all attributes.
We can check the null value of <code class="docutils literal notranslate"><span class="pre">set_func</span></code> or <code class="docutils literal notranslate"><span class="pre">get_func</span></code> with
<code class="docutils literal notranslate"><span class="pre">TEST_ASSERT_NULL</span></code>. This way we ensure that our set/get callbacks are
correctly defined.</p>
<p>We also define a <code class="docutils literal notranslate"><span class="pre">received_frame</span></code> buffer that allows us to test
get/set functions.</p>
<p>Then we add the stub definition in our <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> function :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Called before each and every test</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setUp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>

<span class="w">  </span><span class="c1">// Unset previous definition get/set functions</span>
<span class="w">  </span><span class="n">configuration_get</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">configuration_set</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">tone_number_get</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="n">received_frame</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">received_frame</span><span class="p">));</span>
<span class="w">  </span><span class="n">received_frame_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Resolution functions</span>
<span class="w">  </span><span class="n">attribute_resolver_register_rule_Stub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attribute_resolver_register_rule_stub</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s good practice to init the functions and frame buffer to its default
value before each test.</p>
<section id="z-wave-get-test">
<h4>Z-Wave Get test<a class="headerlink" href="#z-wave-get-test" title="Permalink to this heading"></a></h4>
<p>Now we can write a simple test for the configuration get :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_sound_switch_configuration_get_happy_case</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Ask for a Get Command, should always be the same</span>
<span class="w">  </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">configuration_get</span><span class="p">);</span>
<span class="w">  </span><span class="n">configuration_get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">received_frame</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">expected_frame</span><span class="p">[]</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">,</span><span class="w"> </span><span class="n">SOUND_SWITCH_CONFIGURATION_GET</span><span class="p">};</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">expected_frame</span><span class="p">),</span><span class="w"> </span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_UINT8_ARRAY</span><span class="p">(</span><span class="n">expected_frame</span><span class="p">,</span>
<span class="w">                                </span><span class="n">received_frame</span><span class="p">,</span>
<span class="w">                                </span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Nothing special here we should have the Sound Switch command class ID
and the configuration get ID. The next section shows you how to interact
with the attribute store. It could be useful if your get function have
an argument.</p>
</section>
<section id="z-wave-set-test">
<h4>Z-Wave Set test<a class="headerlink" href="#z-wave-set-test" title="Permalink to this heading"></a></h4>
<p>Let’s now test the set function :</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">test_sound_switch_configuration_set_happy_case</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">volume</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">tone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Attribute tree is empty as this point so we add it here</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">volume_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_add_node</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_VOLUME</span><span class="p">,</span><span class="w"> </span><span class="n">endpoint_id_node</span><span class="p">);</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">tone_node</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_add_node</span><span class="p">(</span><span class="n">ATTRIBUTE_COMMAND_CLASS_SOUND_SWITCH_CONFIGURED_DEFAULT_TONE_IDENTIFIER</span><span class="p">,</span><span class="w"> </span><span class="n">endpoint_id_node</span><span class="p">);</span>

<span class="w">  </span><span class="n">attribute_store_set_desired</span><span class="p">(</span><span class="n">volume_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>
<span class="w">  </span><span class="n">attribute_store_set_desired</span><span class="p">(</span><span class="n">tone_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tone</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">tone</span><span class="p">));</span>

<span class="w">  </span><span class="n">TEST_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">configuration_set</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// We can either set the volume_node or tone_here here.</span>
<span class="w">  </span><span class="n">configuration_set</span><span class="p">(</span><span class="n">volume_node</span><span class="p">,</span><span class="w"> </span><span class="n">received_frame</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">received_frame_size</span><span class="p">);</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">expected_frame</span><span class="p">[]</span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">COMMAND_CLASS_SOUND_SWITCH</span><span class="p">,</span><span class="w"> </span><span class="n">SOUND_SWITCH_CONFIGURATION_SET</span><span class="p">,</span><span class="w"> </span><span class="n">volume</span><span class="p">,</span><span class="w"> </span><span class="n">tone</span><span class="p">};</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">expected_frame</span><span class="p">),</span><span class="w"> </span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="w">  </span><span class="n">TEST_ASSERT_EQUAL_UINT8_ARRAY</span><span class="p">(</span><span class="n">expected_frame</span><span class="p">,</span>
<span class="w">                                </span><span class="n">received_frame</span><span class="p">,</span>
<span class="w">                                </span><span class="n">received_frame_size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We need to manually set the node value since the attribute tree should
be empty.</p>
<p>We set the desired values in our attribute store (<code class="docutils literal notranslate"><span class="pre">endpoint_id_node</span></code>
is automatically set by test helper function) and call the set function.
This way, we can see if the set function is correctly getting the
attributes from the attribute store.</p>
<p>This should cover the basic of unit testing your Z-Wave command class.
Don’t forget to also test edge cases and not just the happy cases.
compliance</p>
</section>
</section>
</section>
<section id="z-wave-self-certification-with-the-compliance-test-tool-ctt">
<span id="id5"></span><h2>Z-Wave Self-Certification with the Compliance Test Tool (CTT)<a class="headerlink" href="#z-wave-self-certification-with-the-compliance-test-tool-ctt" title="Permalink to this heading"></a></h2>
<p>The Z-Wave Compliance Test Tool (CTT) is provided by the Z-Wave
Alliance. The CTT is designed to ensure that developers have a tool to
assist in performing the self-certification tests required for the
Z-Wave certification. Note that the use of the CTT does not guarantee
certification, but it is a good starting point to know if your command
class implementation is robust.</p>
</section>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this heading"></a></h2>
<p>To test the ZPC controller you’ll need 3 Z-Wave boards:</p>
<ul class="simple">
<li><p>Two flashed with the <code class="docutils literal notranslate"><span class="pre">Z-Wave</span> <span class="pre">-</span> <span class="pre">NCP</span> <span class="pre">Serial</span> <span class="pre">API</span> <span class="pre">Controller</span></code> demo</p>
<ul>
<li><p>One for CTT</p></li>
<li><p>One for ZPC</p></li>
</ul>
</li>
<li><p>One flashed with the <code class="docutils literal notranslate"><span class="pre">Z-Wave</span> <span class="pre">-</span> <span class="pre">NCP</span> <span class="pre">Serial</span> <span class="pre">API</span> <span class="pre">End</span> <span class="pre">Device</span></code> demo</p>
<ul>
<li><p>One for CTT</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Make sure you select the demo with the right region.</p>
</div>
<p>You need to create an account in
<a class="reference external" href="https://certification.z-wavealliance.org">https://certification.z-wavealliance.org</a> to have access to the CTT tool.
Once you are in, <a class="reference external" href="https://certification.z-wavealliance.org/wiki/index.php/Compliance_Test_Tool_(CTT)">download the latest version of
CTT</a>.</p>
</section>
<section id="setup-the-ctt-project">
<h2>Setup the CTT project<a class="headerlink" href="#setup-the-ctt-project" title="Permalink to this heading"></a></h2>
<p>Launch CTT and create a new project. Select the
<code class="docutils literal notranslate"><span class="pre">Project</span> <span class="pre">based</span> <span class="pre">on</span> <span class="pre">data</span> <span class="pre">from</span> <span class="pre">Z-Wave</span> <span class="pre">Device</span></code> option :</p>
<figure class="align-default">
<img alt="Step 2 - Project type in CTT" src="../../_images/ctt_project_type.png" />
</figure>
<p>This allows you to not create a whole Certification Case for your
product and run specific tests.</p>
<p>Next, select the devices used in CTT. When refreshing the device list
you should at least have 2 controllers and 1 end device available :</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Examining available devices...

 * COM3
 * COM4            - ControllerBridgeLib (Z-Wave 7.20) ZW080x Series detected.
 * COM5            - ControllerBridgeLib (Z-Wave 7.20) ZW070x Series detected.
 * COM8            - EndDeviceLib (Z-Wave 7.20) ZW070x Series detected.

   - 3 devices found -
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Refresh</span> <span class="pre">Device</span> <span class="pre">List</span></code> button should fill the fields automatically
:</p>
<figure class="align-default">
<img alt="Step 3 - CTT devices" src="../../_images/ctt_ctt_devices_setup.png" />
</figure>
<p>Next, you have to specify the type of DUT (Device Under Test). Since we
want to test a controller we have to select
<code class="docutils literal notranslate"><span class="pre">DUT</span> <span class="pre">is</span> <span class="pre">a</span> <span class="pre">Static</span> <span class="pre">Controller</span></code> :</p>
<figure class="align-default">
<img alt="Step 4 - DUT" src="../../_images/ctt_dut_static_controller.png" />
</figure>
<p>Next, you should have ZPC running to include the CTT devices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you use WSL
<a href="#id6"><span class="problematic" id="id7">`usbipd&lt;https://learn.microsoft.com/en-us/windows/wsl/connect-usb&gt;`__</span></a>
can help you connect your Z-Wave controller to ZPC.</p>
</div>
<p><strong>You can skip Step 5 - CTT includes DUT and move to the next step DUR
includes CTT.</strong></p>
<p>In Step 6 DUT includes CTT, start by pressing Reset for the
<code class="docutils literal notranslate"><span class="pre">Reset</span> <span class="pre">CTT</span> <span class="pre">Controller</span></code> step.</p>
<p>Then, you’ll have reset ZPC and start add mode. You can do that either
in the Dev GUI or in CLI.</p>
<figure class="align-default">
<img alt="Step 6 - add mode" src="../../_images/ctt_step_6_reset_dut.png" />
</figure>
<p>In CLI :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ZPC&gt;<span class="w"> </span>zwave_set_default
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:49:23.791945<span class="w"> </span>&lt;i&gt;<span class="w"> </span><span class="o">[</span>zwave_command_association<span class="o">]</span><span class="w"> </span>Reset<span class="w"> </span>step:<span class="w"> </span>Associations<span class="w"> </span>clean-up
...

ZPC&gt;<span class="w"> </span>zwave_add_node
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:50:13.360236<span class="w"> </span>&lt;i&gt;<span class="w"> </span><span class="o">[</span>zwave_network_managment<span class="o">]</span><span class="w"> </span>Initiating<span class="w"> </span>a<span class="w"> </span>Z-Wave<span class="w"> </span>Network<span class="w"> </span>Inclusion
</pre></div>
</div>
<p>Then, you’ll have to set the DSK to include the CTT controller :</p>
<figure class="align-default">
<img alt="Step 6 - DSK" src="../../_images/ctt_step_6_dsk.png" />
</figure>
<p>In CLI:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ZPC&gt;zwave_accept_dsk<span class="w"> </span><span class="m">34080</span>
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:54:38.492938<span class="w"> </span>&lt;W&gt;<span class="w"> </span><span class="o">[</span>process.c<span class="o">]</span><span class="w"> </span>Process<span class="w"> </span>zwave_network_management_process<span class="w"> </span>took<span class="w"> </span><span class="m">59</span><span class="w"> </span>ms<span class="w"> </span>to<span class="w"> </span>execute<span class="w"> </span>event<span class="w"> </span><span class="m">16</span>.
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:54:38.493143<span class="w"> </span>&lt;i&gt;<span class="w"> </span><span class="o">[</span>zwave_controller_dispatch<span class="o">]</span><span class="w"> </span>New<span class="w"> </span>NodeID<span class="w"> </span><span class="m">2</span><span class="w"> </span>has<span class="w"> </span>joined<span class="w"> </span>the<span class="w"> </span>network.<span class="w"> </span>Granted<span class="w"> </span>keys:<span class="w"> </span>0x00<span class="w"> </span>-<span class="w"> </span>Protocol:<span class="w"> </span><span class="m">0</span>
<span class="m">2023</span>-Nov-29<span class="w"> </span><span class="m">11</span>:54:38.493211<span class="w"> </span>&lt;i&gt;<span class="w"> </span><span class="o">[</span>zwave_controller_dispatch<span class="o">]</span><span class="w"> </span>DSK:<span class="w"> </span><span class="m">34080</span>-61449-35120-42836-29835-32220-46142-63322
</pre></div>
</div>
<p>Once it’s included, you can click on the <code class="docutils literal notranslate"><span class="pre">Done</span></code> button of
<code class="docutils literal notranslate"><span class="pre">Inclusion</span> <span class="pre">done;</span> <span class="pre">wait</span> <span class="pre">for</span> <span class="pre">DUT</span> <span class="pre">interviewing</span> <span class="pre">CTT</span></code> step.</p>
<p>The setup is now complete and you should see 2 controllers in the Dev
Gui :</p>
<figure class="align-default">
<img alt="Step 6 - final" src="../../_images/ctt_step_6_final.png" />
</figure>
<p>To finish the project creation you have to answer some questions about
the DUT:</p>
<figure class="align-default">
<img alt="Step 7 - questions" src="../../_images/ctt_step_7_questions.png" />
</figure>
<p>Select option according to the screenshot above. You can select either
the command class you want to test or say yes to all even if they are
not supported.</p>
</section>
<section id="run-the-tests">
<h2>Run the tests<a class="headerlink" href="#run-the-tests" title="Permalink to this heading"></a></h2>
<p>The commands class tests can be found under the Interactive Tests
section:</p>
<figure class="align-default">
<img alt="Interactive test" src="../../_images/ctt_interactive_tests.png" />
</figure>
<p>Click on the pending link to have access to the complete list of command
class tests :</p>
<figure class="align-default">
<img alt="Test list" src="../../_images/ctt_test_list.png" />
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only the supported command class you registered as controlled
in Step 7 of project creation will show up.</p>
</div>
<p>The ZPC prints its supported command class at startup :</p>
<div class="highlight-{text} notranslate"><div class="highlight"><pre><span></span>$&gt; zpc
| Command Class                  | Version | Support | Control | Security Level              | Comment |
| ------------------------------ | ------- | ------- | ------- | --------------------------- | ------- |
| Alarm Sensor                   |       1 |         |       x | N/A                         |         |
| Association                    |       2 |       x |       x | Network Scheme              |         |
| Association Group Info (AGI)   |       3 |       x |       x | Network Scheme              |         |
| Barrier Operator               |       1 |         |       x | N/A                         |         |
| Basic                          |       2 |         |       x | N/A                         |         |
| Battery                        |       3 |         |       x | N/A                         | Control Part is auto-generated. |
| Binary Sensor                  |       1 |         |       x | N/A                         | Control Part is auto-generated. |
| Binary Switch                  |       2 |         |       x | N/A                         |         |
| Central Scene                  |       3 |         |       x | N/A                         | Partial control: key attributes are not displayed in the UI. |
| Color Switch                   |       3 |         |       x | N/A                         | Partial Control:&lt;br&gt;1. Durations are ignored&lt;br&gt;2. No support for Start/Stop Level Change&lt;br&gt;3. No support for other Color Component IDs than 0,1,2,3,4 |
| Configuration                  |       4 |         |       x | N/A                         |         |
| Device Reset Locally           |       1 |       x |       x | Network Scheme              |         |
| Door Lock                      |       4 |         |       x | N/A                         |         |
| Firmware Update                |       7 |       x |       x | Network Scheme              |         |
| Inclusion Controller           |       1 |       x |       x | Unencrypted                 |         |
| Indicator                      |       3 |       x |       x | Network Scheme              |         |
| Manufacturer Specific          |       2 |       x |       x | Network Scheme              |         |
| Meter                          |       6 |         |       x | N/A                         | Partial control: &lt;br&gt;1. Meter Reset Command is not supported due to missing dotdot ZCL equivalent functionality. |
| Multi Channel                  |       4 |         |       x | N/A                         |         |
| Multi Channel Association      |       3 |       x |       x | Network Scheme              |         |
| Multi Command                  |       1 |       x |         | Unencrypted                 |         |
| Multilevel Sensor              |      11 |         |       x | N/A                         | Partial control: &lt;br&gt;1. Not all scales are supported&lt;br&gt;2. Not all types are shown in the UI. |
| Multilevel Switch              |       4 |         |       x | N/A                         |         |
| Notification                   |       8 |         |       x | N/A                         | Partial Control: &lt;br&gt;1. No Push/Pull discovery is done.&lt;br&gt;2. No Pull sensor support. &lt;br&gt;3. Unknown types are not supported. &lt;br&gt;4. No Regular probing is done.  |
| Powerlevel                     |       1 |       x |         | Network Scheme              |         |
| Scene Activation               |       1 |         |       x | N/A                         |         |
| Scene Actuator Configuration   |       1 |         |       x | N/A                         | No interview performed automatically. |
| Scene Controller Configuration |       1 |         |       x | N/A                         |         |
| Security 0                     |       1 |       x |       x | Unencrypted                 |         |
| Security 2                     |       1 |       x |       x | Unencrypted                 |         |
| Sound Switch                   |       1 |         |       x | N/A                         |         |
| Supervision                    |       2 |       x |       x | Unencrypted                 |         |
| Thermostat Mode                |       3 |         |       x | N/A                         | Partial Control: Not all modes can be set |
| Thermostat Setpoint            |       3 |         |       x | N/A                         | Partial Control: &lt;br&gt;1. No discovery of ambiguous types in v1-v2 &lt;br&gt;2. Only a few setpoints can be configured. &lt;br&gt;3. Precision/size fields in the set are determined &lt;br&gt;automatically by the controller.  |
| Time                           |       1 |       x |         | Unencrypted                 |         |
| Transport Service              |       2 |       x |       x | Unencrypted                 |         |
| User Code                      |       2 |         |       x | N/A                         | Partial Control |
| Version                        |       3 |       x |       x | Network Scheme              |         |
| Wake Up                        |       3 |         |       x | N/A                         |         |
| Z-Wave Plus Info               |       2 |       x |       x | Unencrypted                 |         |
</pre></div>
</div>
<p>You can start a test by right clicking on it and press <code class="docutils literal notranslate"><span class="pre">Run</span></code>. The test
will ask you some questions about your implementation and to send
specific Z-Wave command. Those can be triggered through MQTT or via the
Dev GUI.</p>
<p>A set of python scripts are available for you to easily send commands to
CTT in <code class="docutils literal notranslate"><span class="pre">applications/zpc/scripts/certification</span></code>.</p>
</section>
</section>


           </div>
          </div>
          <footer>
    <hr/>
    <p>Copyright © 2023 Silicon Laboratories. All rights reserved.</p>
</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>